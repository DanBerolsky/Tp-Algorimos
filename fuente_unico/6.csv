buscoAlgo_enCodigoDe,(funcion1, funcion2, csv),arbol_de_invocacion.py,, ,     cuerpo = depurarLineas(funcion2, csv),     contador = 0, ,     for linea in cuerpo:,         if funcion1 + "(" in linea:,             contador += 1, ,     return contador
buscoLlamadasAOtrasFunciones,funcion, indice, listaDeNombres, csv,arbol_de_invocacion.py,, ,     a = funcion + " (" + str(num_de_lineas(depurarLineas(funcion, csv))) + ")",     print(a, end=""),     contador = 0,     primer_rama = True, ,     for nombre in listaDeNombres:, ,         cant_llamados = buscoAlgo_enCodigoDe(nombre, funcion, csv), ,         if not primer_rama:, ,             if cant_llamados == 1:,                 print(" " * (len(a) + indice), end=""),                 print(" --> ", end=""),                 buscoLlamadasAOtrasFunciones(nombre, indice + len(a) + 5, listaDeNombres, csv), ,             elif cant_llamados > 1:,                 for f in range(cant_llamados):,                     print(" " * (len(a) + indice), end=""),                     print(" --> ", end=""),                     buscoLlamadasAOtrasFunciones(nombre, indice + len(a) + 5, listaDeNombres, csv), ,             else:,                 contador += 1, ,         else:, ,             if cant_llamados == 1:,                 print(" --> ", end=""),                 buscoLlamadasAOtrasFunciones(nombre, indice + len(a) + 5, listaDeNombres, csv),                 primer_rama = False, ,             elif cant_llamados > 1:,                 print(" --> ", end=""),                 buscoLlamadasAOtrasFunciones(nombre, indice + len(a) + 5, listaDeNombres, csv),                 for f in range(cant_llamados - 1):,                     print(" " * (len(a) + indice), end=""),                     print(" --> ", end=""),                     buscoLlamadasAOtrasFunciones(nombre, indice + len(a) + 5, listaDeNombres, csv),                 primer_rama = False, ,             else:,                 contador += 1, ,     if contador == len(listaDeNombres):,         print(""), ,     return, , 
cantidad_de_espacios,(nombre_funcion),Informacion_por_desarrollador.py,    ,   ,     if 8 + len(nombre_funcion)<33:,         ,         espacios = -1 * (8 + len(nombre_funcion) - 33),     ,     else:,         ,         espacios = 2, ,     return espacios  
capturo_datos,(),Informacion_por_desarrollador.py,    , ,     informacion_deseada = {},     ,     lineas_totales_por_autor = {},     ,     total_linea = 0,     ,     with open("comentarios.csv","rt") as archivo_comentarios:,         ,         linea_archivos_comentarios = archivo_comentarios.readline(), ,         while linea_archivos_comentarios != "":,             ,             linea_a_lista_de_datos = linea_archivos_comentarios.split(","),             ,             nombre_funcion = linea_a_lista_de_datos[0],             ,             autor = linea_a_lista_de_datos[1].lstrip("[").rstrip("]"),             ,             informacion_deseada[nombre_funcion] = {"Autor":autor,"Lineas_por_funcion":None},             ,             linea_archivos_comentarios = archivo_comentarios.readline(), ,     with open ("fuente_unico.csv","rt") as archivo_fuente_unico:,         ,         linea_archivos_fuente_unico = archivo_fuente_unico.readline(),         ,         while linea_archivos_fuente_unico != "":,             ,             linea_a_lista_de_datos = linea_archivos_fuente_unico.split(","),             ,             contador_lineas = 0, ,             funcion_actual = linea_a_lista_de_datos[0],             ,             total_linea += len(linea_a_lista_de_datos[3:]),             ,             contador_lineas = len(linea_a_lista_de_datos[3:]),             ,             for clave in informacion_deseada.keys():,                 ,                 if clave == funcion_actual:,                     ,                     informacion_deseada[clave]["Lineas_por_funcion"] = contador_lineas,                     ,                     if informacion_deseada[clave]["Autor"] in lineas_totales_por_autor.keys():,                         ,                         lineas_totales_por_autor[informacion_deseada[clave]["Autor"]] += contador_lineas                    ,                     ,                     else:,                         lineas_totales_por_autor[informacion_deseada[clave]["Autor"]] = contador_lineas,             ,             linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,     porcentajes = {},     ,     for clave in lineas_totales_por_autor.keys():,         ,         porcentajes[clave] = int((lineas_totales_por_autor[clave]/total_linea)*100), ,     datos_finales = sorted(informacion_deseada.items(), key = lambda autor: autor[1]["Autor"]),     ,     return datos_finales,porcentajes
ciclar_modulos,(lista_modulos, tipo),merge.py,,     if tipo == 1:,         index_nombre = 0,         while len(lista_modulos[-1]) > 2:,             if len(lista_modulos[-1]) % 2 != 0:,                 ult_elemento_impar = lista_modulos[-1][-1],                 lista_modulos[-1].remove(lista_modulos[-1][-1]),                 index = 1,                 lista_modulos.append([]),                 while (index <= len(lista_modulos[-2]) - 1):,                     nombre_a_escribir = ".\\fuente_unico\\" + str(index_nombre) + ".csv",                     index_nombre += 1,                     merge_2(lista_modulos[-2][index], lista_modulos[-2][index - 1], nombre_a_escribir),                     index += 2    ,                     lista_modulos[-1].append(nombre_a_escribir),                 lista_modulos[-1].append(ult_elemento_impar),             else:,                 index = 1,                 lista_modulos.append([]),                 while (index <= len(lista_modulos[-2]) - 1):,                     nombre_a_escribir = ".\\fuente_unico\\" + str(index_nombre) + ".csv",                     index_nombre += 1,                     merge_2(lista_modulos[-2][index], lista_modulos[-2][index - 1], nombre_a_escribir),                     index += 2    ,                     lista_modulos[-1].append(nombre_a_escribir),         merge_2(lista_modulos[-1][0], lista_modulos[-1][1], "fuente_unico.csv"),     else:,         index_nombre = 65,         while len(lista_modulos[-1]) > 2:,             if len(lista_modulos[-1]) % 2 != 0:,                 ult_elemento_impar = lista_modulos[-1][-1],                 lista_modulos[-1].remove(lista_modulos[-1][-1]),                 index = 1,                 lista_modulos.append([]),                 while (index <= len(lista_modulos[-2]) - 1):,                     nombre_a_escribir = ".\\comentarios\\" + chr(index_nombre) + ".csv",                     index_nombre += 1,                     merge_2(lista_modulos[-2][index], lista_modulos[-2][index - 1], nombre_a_escribir),                     index += 2    ,                     lista_modulos[-1].append(nombre_a_escribir),                 lista_modulos[-1].append(ult_elemento_impar),             else:,                 index = 1,                 lista_modulos.append([]),                 while (index <= len(lista_modulos[-2]) - 1):,                     nombre_a_escribir = ".\\comentarios\\" + chr(index_nombre) + ".csv",                     index_nombre += 1,                     merge_2(lista_modulos[-2][index], lista_modulos[-2][index - 1], nombre_a_escribir),                     index += 2    ,                     lista_modulos[-1].append(nombre_a_escribir), ,         merge_2(lista_modulos[-1][0], lista_modulos[-1][1], "comentarios.csv")
contar_elementos_varios,(lista, lista_comentarios),Panel_General.py,    cantidad_elementos = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": "NO"},     j = 4,     while j < len(lista):,         if lista[j].strip().startswith("if") or lista[j].strip().startswith(,             cantidad_elementos["if"] += 1,         elif lista[j].strip().startswith("while"):,             cantidad_elementos["while"] += 1,         elif lista[j].strip().startswith("for"):,             cantidad_elementos["for"] += 1,         elif lista[j].strip().startswith("return"):,             cantidad_elementos["returns"] += 1,         elif lista[j].strip().startswith("break"):,             cantidad_elementos["break"] += 1,         elif lista[j].strip().startswith("exit"):,             cantidad_elementos["exit"] += 1,         if lista_comentarios[2].strip().startswith("[Ayuda:"):,             cantidad_elementos["ayuda"] = "SI",         j = j + 1,     return cantidad_elementos
contar_invocaciones,(nombre_funcion, lista),Panel_General.py,    i = 0,     invocaciones_dict = {"Cantidad de Invocaciones": 0},     while i < len(lista):,         j = 4,         while j < len(lista[i]):,             if nombre_funcion in lista[i][j]:,                 invocaciones_dict["Cantidad de Invocaciones"] += 1,             j = j + 1,         i = i + 1,     return invocaciones_dict
depurarLineas,(funcion, csv),arbol_de_invocacion.py,, ,     dicc = modulo_csv.leer_csv(csv),     cuerpo_de_funcion_limpio = [],     ,     for key in dicc:,         if key == funcion:,             for linea in dicc[key]:,                 if linea.strip("\n \t"):,                     cuerpo_de_funcion_limpio.append(linea), ,     return cuerpo_de_funcion_limpio[2:]
escribir,linea, archivo,merge.py,    archivo.write(linea), 
escribir_imprimir ,(contenido_a_mostrar,archivo_a_abrir,modalida_de_apertura,escritura),Informacion_por_desarrollador.py,import Salida,  , def capturo_datos():,     , ,     informacion_deseada = {},     ,     lineas_totales_por_autor = {},     ,     total_linea = 0,     ,     with open("comentarios.csv","rt") as archivo_comentarios:,         ,         linea_archivos_comentarios = archivo_comentarios.readline(), ,         while linea_archivos_comentarios != "":,             
funcionesIndependientes,(),arbol_de_invocacion.py,,     dicc_funciones = modulo_csv.quien_invoca_a_quien(),     nombresFunciones = generarListaNombresFunciones("fuente_unico.csv"), ,     for key in dicc_funciones:,         for i in range(len(dicc_funciones[key])):,             if dicc_funciones[key][i][0] in nombresFunciones:,                 nombresFunciones.remove(dicc_funciones[key][i][0]), ,     return nombresFunciones
generarArbol,listaFuncionesIndependientes, csv,arbol_de_invocacion.py,, ,     nombres = generarListaNombresFunciones(csv), ,     for funcion in listaFuncionesIndependientes:,         buscoLlamadasAOtrasFunciones(funcion, 0, nombres, csv),         print(""), ,     return, , 
generarListaNombresFunciones,(csv),arbol_de_invocacion.py,, ,     dicc = modulo_csv.leer_csv(csv),     listaDeNombresDeOtrasFunciones = [key for key in dicc], ,     return listaDeNombresDeOtrasFunciones
merge_2,modulo1, modulo2, modulo_a_escribir,merge.py,,     modulo1 = open(modulo1),     modulo2 = open(modulo2),     linea1 = modulo1.readline(),     linea2 = modulo2.readline(), ,     with open(modulo_a_escribir, "a") as escritura:,         while linea1 != "" and linea2 != "":,         ,             if linea1 < linea2:,                 escritura.write(linea1),                 linea1 = modulo1.readline(),             elif linea1 > linea2:,                 escritura.write(linea2),                 linea2 = modulo2.readline(), ,         if linea1 != "":,             while linea1:,                 escribir(linea1, escritura),                 linea1 = modulo1.readline(),         elif linea2 != "":,             while linea2:,                 escribir(linea2, escritura),                 linea2 = modulo2.readline(),     modulo1.close(),     modulo2.close(), , 
num_de_lineas,(cuerpoDeFuncion),arbol_de_invocacion.py,, ,     cantLineas = 0, ,     for linea in cuerpoDeFuncion:,         cantLineas += 1, ,     return cantLineas
organizar_datos,(lista),Panel_General.py,    j = 0,     primeros_3 = {"Nombre de Funcion": lista[0] + lista[2], "Cantidad de Parametros": lista[1].count('('),,                   "Cantidad de Lineas": len(lista) - 3},     return primeros_3
panel_principal,(),Panel_General.py,    with open('comentarios.csv', 'r') as comentarios:,         reader = csv.reader(comentarios),         lista_de_comentarios = [],         for fila in reader:,             lista_de_comentarios.append(fila),     with open('fuente_unico.csv', 'r') as file:,         reader = csv.reader(file),         lista_completa = [],         lista_final = {},         datos = [],         for row in reader:,             lista_completa.append(row),         lista1 = lista_completa,         i = 0,         while i < len(lista_completa):,             lista_final_1 = organizar_datos(lista_completa[i]),             lista_final_2 = contar_invocaciones(lista_completa[i][0], lista_completa),             lista_final_3 = contar_elementos_varios(lista_completa[i], lista_de_comentarios[i]),             lista_final.update(lista_final_1),             lista_final.update(lista_final_2),             lista_final.update(lista_final_3),             datos.append(lista_final),             lista_final = {},             i = i + 1, ,     header = datos[0].keys(),     rows = [x.values() for x in datos],     print(tabulate.tabulate(rows, header))
participacion_info ,lista_tuplas_funciones_autor_lineas_por_autor, diccionario_de_porcentajes_por_autores,Informacion_por_desarrollador.py,    , ,     autor_anterior = None,     ,     titulo = "\n\tInforme de Desarrollo Por Autor\n",     Salida.escribir_imprimir(titulo, "participacion.txt", "a", titulo),     ,     for indice in range(len(lista_tuplas_funciones_autor_lineas_por_autor)):     ,         ,         nombre_funcion = lista_tuplas_funciones_autor_lineas_por_autor[indice][0],         ,         autor = lista_tuplas_funciones_autor_lineas_por_autor[indice][1]["Autor"], ,         lineas_funcion = lista_tuplas_funciones_autor_lineas_por_autor[indice][1]["Lineas_por_funcion"], ,         porcentaje = diccionario_de_porcentajes_por_autores[autor],         ,         if autor_anterior == None:,             ,             s1 = autor + "\n\n\tFuncion" + 16*" " + "Lineas"+"\n\t" + 33 * "-",             Salida.escribir_imprimir(s1, "participacion.txt", "a", "\n" + s1),             ,             espacios = cantidad_de_espacios(nombre_funcion),             s2 = "\t" + nombre_funcion + (" " * espacios) + str(lineas_funcion),             Salida.escribir_imprimir(s2, "participacion.txt", "a","\n" + s2 ),             ,             contador_lineas_totales = 0,             ,             contador_funciones_totales = 0,             ,             contador_funciones = 0, ,             contador_lineas = 0, ,             porcentaje_anterior = porcentaje, ,             autor_anterior = autor, ,         elif autor_anterior != autor:,             ,             s1 = "\t"+str(contador_funciones) + " Funciones - Lineas\t " + str(contador_lineas) + "  " + str(porcentaje_anterior)+"%\n",             Salida.escribir_imprimir(s1, "participacion.txt", "a", "\n" + s1),             ,             s2 = autor +"\n\n\tFuncion"+16*" "+"Lineas\n\t" + 33*"-",             Salida.escribir_imprimir(s2, "participacion.txt", "a", "\n" + s2),             ,             espacios = cantidad_de_espacios(nombre_funcion),             s3 = "\t" + nombre_funcion + (" " * espacios) + str(lineas_funcion),             Salida.escribir_imprimir(s3, "participacion.txt", "a", "\n" + s3),            ,             contador_funciones = 0, ,             contador_lineas = 0, ,             porcentaje_anterior = porcentaje, ,         else:,             ,             espacios = cantidad_de_espacios(nombre_funcion),             s1 = "\t" + nombre_funcion + " "*espacios + str(lineas_funcion),             Salida.escribir_imprimir(s1, "participacion.txt", "a", "\n" + s1), ,         contador_lineas_totales += int(lineas_funcion), ,         contador_funciones_totales += 1, ,         contador_funciones += 1, ,         contador_lineas += int(lineas_funcion), ,         autor_anterior = autor, ,         if indice == len(lista_tuplas_funciones_autor_lineas_por_autor)-1 :,             ,             s1 = "\t"+str(contador_funciones) + " Funciones - Lineas\t " + str(contador_lineas) + "  " + str(porcentaje)+"%\n\n",             Salida.escribir_imprimir(s1, "participacion.txt", "a", "\n" + s1),             ,             s2 = "Total: "+ str(contador_funciones_totales) + " Funciones - lineas\t " + str(contador_lineas_totales)+"\n",             Salida.escribir_imprimir(s2, "participacion.txt", "a", "\n" + s2),                    , 
