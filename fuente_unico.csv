participacion_info ,informacion,informacion2,Informacion_por_desarrollador.py,    ,        [Ayuda: brindar datos sobre la participaciï¿½n de cada uno de los ,     integrantes en el desarrollo de la aplicaciï¿½n.,     Ademas de mostrar la informacion por pantalla,,     genera la misma salida al archivo ï¿½participacion.txtï¿½ ], ,     autor_anterior = None,     total_funciones = 0,     ,     titulo = "\n\tInforme de Desarrollo Por Autor\n",     muestro_salida.impresiones(titulo),     ,     archivo_participacion_txt(titulo),     ,     ,     for indice in range(len(informacion)):     ,         ,         nombre_funcion = informacion[indice][0],         ,         autor, lineas_funcion = informacion[indice][1], ,         porcentaje = informacion2[autor], ,         total_funciones += 1, ,         if autor_anterior == None:,             ,             s1="Autor: " + autor +"\n\n\tFuncion" + 16*" " + "Lineas"+"\n\t" + 33 * "-",             muestro_salida.impresiones(s1),             ,             espacios = cantidad_de_espacios(nombre_funcion),             s2 = "\t" + nombre_funcion + " "*espacios + str(lineas_funcion),             muestro_salida.impresiones(s2),             ,             archivo_participacion_txt("\n"+s1),             archivo_participacion_txt("\n" + s2),             ,             contador_lineas_totales = 0,             ,             contador_funciones_totales = 0,             ,             contador_funciones = 0, ,             contador_lineas = 0, ,             porcentaje_anterior = porcentaje, ,             autor_anterior = autor, ,         elif autor_anterior!=autor:,             ,             s1 = "\t"+str(contador_funciones) + " Funciones - Lineas\t " + str(contador_lineas) + "  " + str(porcentaje_anterior)+"%\n",             muestro_salida.impresiones(s1),             ,             s2 = "Autor: " + autor +"\n\n\tFuncion"+16*" "+"Lineas\n\t" + 33*"-",             muestro_salida.impresiones(s2),             ,             espacios = cantidad_de_espacios(nombre_funcion),             s3 = "\t" + nombre_funcion + " "*espacios + str(lineas_funcion),             muestro_salida.impresiones(s3),             ,             archivo_participacion_txt("\n" + s1),             archivo_participacion_txt("\n"+ s2),             archivo_participacion_txt("\n" + s3),             , ,             contador_funciones = 0, ,             contador_lineas = 0, ,             porcentaje_anterior = porcentaje, ,         else:,         ,             espacios = cantidad_de_espacios(nombre_funcion),             s1 = "\t" + nombre_funcion + " "*espacios + str(lineas_funcion),             muestro_salida.impresiones(s1),             ,             archivo_participacion_txt("\n" + s1),             , ,         contador_lineas_totales += int(lineas_funcion), ,         contador_funciones_totales += 1, ,         contador_funciones += 1, ,         contador_lineas += int(lineas_funcion), ,         autor_anterior = autor, ,         if indice == len(informacion)-1 :,             ,             s1="\t"+str(contador_funciones) + " Funciones - Lineas\t " + str(contador_lineas) + "  " + str(porcentaje)+"%\n\n",             muestro_salida.impresiones(s1),             s2="Total: "+ str(contador_funciones_totales) + " Funciones - lineas\t " + str(contador_lineas_totales)+"\n",             muestro_salida.impresiones(s2),             ,             archivo_participacion_txt("\n"+s1),             archivo_participacion_txt("\n"+s2)            ,     ,     return None
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,    ,     ,     return sorted(diccionario.items(), key = lambda clave: clave[0], reverse = True)
main,,programa_principal.py,    ,     , ,     import m_generar_archivos_csv,     txt = 'programas.txt',     m_generar_archivos_csv.armar_csv_funciones(txt),     ,     import Informacion_por_desarrollador,     informacion,porcentaje = Informacion_por_desarrollador.capturo_datos(),     Informacion_por_desarrollador.participacion_info(informacion,porcentaje),     ,     return None
leer,archivo,m_generar_archivos_csv.py,    ,     ,     lineas = [linea.rstrip('\n') for linea in archivo],     ,     return lineas
impresiones ,contenido_a_mostrar,muestro_salida.py,    , ,     print(contenido_a_mostrar), ,     return None
contar_funciones,linea,contar_funciones.py,    cantidad_funciones = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": 0},     if linea.strip().startswith("if"):,         cantidad_funciones["if"] += 1,     elif linea.strip().startswith("while"):,         cantidad_funciones["while"] += 1,     elif linea.strip().startswith("for"):,         cantidad_funciones["for"] += 1,     elif linea.strip().startswith("return"):,         cantidad_funciones["returns"] += 1,     elif linea.strip().startswith("break"):,         cantidad_funciones["break"] += 1,     elif linea.strip().startswith("exit"):,         cantidad_funciones["exit"] += 1,     elif linea.strip().startswith("[Ayuda: ]"):,         cantidad_funciones["ayuda"] += 1,     return cantidad_funciones
capturo_datos,,Informacion_por_desarrollador.py,    ,     (Nombres de las funciones, autor de la funcion , lineas por funcion y,     porcentaje de lineas del autor, sobre lineas totales del trabajo. ) ], ,     info = {},     ,     lineas_totales_por_autor = {}, ,     total_linea = 0, ,     with open("comentarios.csv","rt") as archivo_comentarios:,         ,         linea = archivo_comentarios.readline(), ,         while linea!="":,             ,             datos = linea.split(","), ,             nombre_funcion = datos[0], ,             autor = datos[1].split(": ")[1].rstrip("]"), ,             info[nombre_funcion] = [autor,None], ,             linea = archivo_comentarios.readline(), ,     with open ("fuente_unico.csv","rt") as ar_fuente:, ,         linea = ar_fuente.readline(), ,         while linea!="":, ,             datos = linea.split(","),             ,             contador_lineas = 0, ,             funcion_actual = datos[0],             ,             total_linea += len(datos[3:]),             ,             contador_lineas = len(datos[3:]),             ,             for clave in info.keys():,                 ,                 if clave == funcion_actual:,                     info[clave][1] = contador_lineas,                     ,                     if info[clave][0] in lineas_totales_por_autor.keys():,                         lineas_totales_por_autor[info[clave][0]]+=contador_lineas,                     ,                     else:,                         lineas_totales_por_autor[info[clave][0]]=contador_lineas, ,             linea = ar_fuente.readline(), ,     porcentajes ={}, ,     for clave in lineas_totales_por_autor.keys():,     ,         porcentajes[clave]=int((lineas_totales_por_autor[clave]/total_linea)*100), ,     ,     datos_finales = sorted(info.items(), key = lambda autor: autor[1][0]),     ,     return datos_finales,porcentajes
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,    ,         [Ayuda: Aquï¿½ se multiplica un espacio por un numero x,         El 8 es cantidad de caracateres que tiene una tabulacion,,         len(nom_fun) es la cantida de caracteres que tiene el nom_fun.,         Despues quiero que partir del carater 32 obtener la cant.lineas.,         Esta cuanta me asegura que el valor lineas_f este uno debajo del otro,,         multiplicando un str espacio la cantidad de veces nesesaria para cada caso. ],   ,     if 8 + len(nombre_funcion)<33:,         espacios = -1 * (8 + len(nombre_funcion) - 33),     else:,         espacios = 2, ,     return espacios            
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,    ,     ,     if nombre_archivo == 'fuente_unico.csv':,     ,         with open (nombre_archivo,"a") as codigo:,             ,             for clave in Estructura_de_datos:,                 ,                 nombre_funcion = clave[0],                 parametros = clave[1][0],                 modulo = clave[1][1],                 cuerpo = clave[1][2],                 ,                 funcion = "\n".join(cuerpo),             ,                 funcion = ", ".join(cuerpo),             ,                 codigo.write(nombre_funcion+","+parametros+","+modulo+","+funcion+"\n"),     ,     elif nombre_archivo == 'comentarios.csv':,         ,         with open (nombre_archivo,"a") as codigo:,             ,             for elementos in Estructura_de_datos:,                 ,                 nombre_funcion = elementos[0],                 nombre_autor = elementos[1][0],                 nombre_ayuda = elementos[1][1],                 resto = elementos[1][2], ,             ,                 funcion = ", ".join(resto),             ,                 codigo.write(nombre_funcion + "," + nombre_autor + "," + nombre_ayuda + "," + funcion + "\n"),     ,     return None
armar_csv_funciones,archivo,m_generar_archivos_csv.py,    ,     ,     nombre_archivo = "fuente_unico.csv",     datos = {},     ,     modulos = abro_ar(archivo),     ,     for modulo in modulos:,         lineas = abro_ar(modulo), ,         for linea in lineas:,                   ,             if linea.startswith('def '):,                 funcion = linea,                 index_inicial = lineas.index(funcion) + 1,                 nombre_funcion = funcion.split('def ')[1].lstrip().split('(')[0],                 parametros = funcion.split('(')[1].lstrip().split(')')[0], ,             elif linea.strip().startswith('return'):,                 linea_return = linea,                 index_final = lineas.index(linea_return) + 1,                 cuerpo = lineas[index_inicial:index_final],                 cuerpo_sin_comment = armar_csv_comentarios(cuerpo,nombre_funcion),                 datos[nombre_funcion] = [parametros,modulo,cuerpo_sin_comment], ,     funciones_alfabeto = ordenar_alfabeticamente(datos),   ,     return modulo_csv.armo_csv(funciones_alfabeto,nombre_archivo)
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,    ,     ,     comentario_triple = '\"\"\"',     nombre_archivo = 'comentarios.csv',     autor = "[Autor:",     ayuda = "[Ayuda:",     nombre_autor = "",     nombre_ayuda = "",     resto = []   ,     datos_comentarios = {}, ,     lista = lista_cuerpo    ,     resto = [j for j in lineas_comentadas if autor not in j and ayuda not in j],     cuerpo_sin_comentarios = [x for x in lista if x not in lineas_comentadas],     ,     for comentarios in lineas_comentadas:,         if autor in comentarios:,             nombre_autor = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],         elif ayuda in comentarios:,             nombre_ayuda = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],             ,             datos_comentarios[nombre_funcion] = [nombre_autor,nombre_ayuda,resto],             ,     comentarios_alfabeto = ordenar_alfabeticamente(datos_comentarios),     ,     modulo_csv.armo_csv(comentarios_alfabeto,nombre_archivo),     ,     return cuerpo_sin_comentarios
archivo_participacion_txt ,agrego,Informacion_por_desarrollador.py,
abro_ar,archivo,m_generar_archivos_csv.py,    , , ,     with open(archivo, encoding="utf8") as archivo_completo: ,        ,         return leer(archivo_completo)
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,    ,     ,     return sorted(diccionario.items(), key = lambda clave: clave[0], reverse = True)
main,,programa_principal.py,    ,     , ,     import m_generar_archivos_csv,     txt = 'programas.txt',     m_generar_archivos_csv.armar_csv_funciones(txt),     ,     import Informacion_por_desarrollador,     informacion,porcentaje = Informacion_por_desarrollador.capturo_datos(),     Informacion_por_desarrollador.participacion_info(informacion,porcentaje),     ,     return None
leer,archivo,m_generar_archivos_csv.py,    ,     ,     lineas = [linea.rstrip('\n') for linea in archivo],     ,     return lineas
impresiones ,contenido_a_mostrar,muestro_salida.py,    , ,     print(contenido_a_mostrar), ,     return None
contar_funciones,linea,contar_funciones.py,    cantidad_funciones = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": 0},     if linea.strip().startswith("if"):,         cantidad_funciones["if"] += 1,     elif linea.strip().startswith("while"):,         cantidad_funciones["while"] += 1,     elif linea.strip().startswith("for"):,         cantidad_funciones["for"] += 1,     elif linea.strip().startswith("return"):,         cantidad_funciones["returns"] += 1,     elif linea.strip().startswith("break"):,         cantidad_funciones["break"] += 1,     elif linea.strip().startswith("exit"):,         cantidad_funciones["exit"] += 1,     elif linea.strip().startswith("[Ayuda: ]"):,         cantidad_funciones["ayuda"] += 1,     return cantidad_funciones
capturo_datos,,Informacion_por_desarrollador.py,    ,     (Nombres de las funciones, autor de la funcion , lineas por funcion y,     porcentaje de lineas del autor, sobre lineas totales del trabajo. ) ], ,     informacion_deseada = {},     ,     lineas_totales_por_autor = {}, ,     total_linea = 0, ,     with open("comentarios.csv","rt") as archivo_comentarios:,         ,         linea_archivos_comentarios = archivo_comentarios.readline(), ,         while linea_archivos_comentarios != "":,             ,             linea_a_lista_de_datos = linea_archivos_comentarios.split(","), ,             nombre_funcion = linea_a_lista_de_datos[0], ,             autor = linea_a_lista_de_datos[1].split(": ")[1].rstrip("]"), ,             informacion_deseada[nombre_funcion] = [autor,None], ,             linea_archivos_comentarios = archivo_comentarios.readline(), ,     with open ("fuente_unico.csv","rt") as archivo_fuente_unico:, ,         linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,         while linea_archivos_fuente_unico != "":, ,             linea_a_lista_de_datos = linea_archivos_fuente_unico.split(","),             ,             contador_lineas = 0, ,             funcion_actual = linea_a_lista_de_datos[0],             ,             total_linea += len(linea_a_lista_de_datos[3:]),             ,             contador_lineas = len(linea_a_lista_de_datos[3:]),             ,             for clave in informacion_deseada.keys():,                 ,                 if clave == funcion_actual:,                     informacion_deseada[clave][1] = contador_lineas,                     ,                     if informacion_deseada[clave][0] in lineas_totales_por_autor.keys():,                         lineas_totales_por_autor[informacion_deseada[clave][0]]+=contador_lineas,                     ,                     else:,                         lineas_totales_por_autor[informacion_deseada[clave][0]]=contador_lineas, ,             linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,     porcentajes ={}, ,     for clave in lineas_totales_por_autor.keys():,     ,         porcentajes[clave]=int((lineas_totales_por_autor[clave]/total_linea)*100), ,     ,     datos_finales = sorted(informacion_deseada.items(), key = lambda autor: autor[1][0]),     ,     return datos_finales,porcentajes
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,    ,         [Ayuda: Aquí se multiplica un espacio por un numero x,         El 8 es cantidad de caracateres que tiene una tabulacion,,         len(nom_fun) es la cantida de caracteres que tiene el nom_fun.,         Despues quiero que partir del carater 32 obtener la cant.lineas.,         Esta cuanta me asegura que el valor lineas_f este uno debajo del otro,,         multiplicando un str espacio la cantidad de veces nesesaria para cada caso. ],   ,     if 8 + len(nombre_funcion)<33:,         espacios = -1 * (8 + len(nombre_funcion) - 33),     else:,         espacios = 2, ,     return espacios  
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,    ,     ,     if nombre_archivo == 'fuente_unico.csv':,     ,         with open (nombre_archivo,"a") as codigo:,             ,             for clave in Estructura_de_datos:,                 ,                 nombre_funcion = clave[0],                 parametros = clave[1][0],                 modulo = clave[1][1],                 cuerpo = clave[1][2],                 ,                 funcion = "\n".join(cuerpo),             ,                 funcion = ", ".join(cuerpo),             ,                 codigo.write(nombre_funcion+","+parametros+","+modulo+","+funcion+"\n"),     ,     elif nombre_archivo == 'comentarios.csv':,         ,         with open (nombre_archivo,"a") as codigo:,             ,             for elementos in Estructura_de_datos:,                 ,                 nombre_funcion = elementos[0],                 nombre_autor = elementos[1][0],                 nombre_ayuda = elementos[1][1],                 resto = elementos[1][2], ,             ,                 funcion = ", ".join(resto),             ,                 codigo.write(nombre_funcion + "," + nombre_autor + "," + nombre_ayuda + "," + funcion + "\n"),     ,     return None
armar_csv_funciones,archivo,m_generar_archivos_csv.py,    ,     ,     nombre_archivo = "fuente_unico.csv",     datos = {},     ,     modulos = abro_ar(archivo),     ,     for modulo in modulos:,         lineas = abro_ar(modulo), ,         for linea in lineas:,                   ,             if linea.startswith('def '):,                 funcion = linea,                 index_inicial = lineas.index(funcion) + 1,                 nombre_funcion = funcion.split('def ')[1].lstrip().split('(')[0],                 parametros = funcion.split('(')[1].lstrip().split(')')[0], ,             elif linea.strip().startswith('return'):,                 linea_return = linea,                 index_final = lineas.index(linea_return) + 1,                 cuerpo = lineas[index_inicial:index_final],                 cuerpo_sin_comment = armar_csv_comentarios(cuerpo,nombre_funcion),                 datos[nombre_funcion] = [parametros,modulo,cuerpo_sin_comment], ,     funciones_alfabeto = ordenar_alfabeticamente(datos),   ,     return modulo_csv.armo_csv(funciones_alfabeto,nombre_archivo)
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,    ,     ,     comentario_triple = '\"\"\"',     nombre_archivo = 'comentarios.csv',     autor = "[Autor:",     ayuda = "[Ayuda:",     nombre_autor = "",     nombre_ayuda = "",     resto = []   ,     datos_comentarios = {}, ,     lista = lista_cuerpo    ,     resto = [j for j in lineas_comentadas if autor not in j and ayuda not in j],     cuerpo_sin_comentarios = [x for x in lista if x not in lineas_comentadas],     ,     for comentarios in lineas_comentadas:,         if autor in comentarios:,             nombre_autor = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],         elif ayuda in comentarios:,             nombre_ayuda = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],             ,             datos_comentarios[nombre_funcion] = [nombre_autor,nombre_ayuda,resto],             ,     comentarios_alfabeto = ordenar_alfabeticamente(datos_comentarios),     ,     modulo_csv.armo_csv(comentarios_alfabeto,nombre_archivo),     ,     return cuerpo_sin_comentarios
abro_ar,archivo,m_generar_archivos_csv.py,    , , ,     with open(archivo, encoding="utf8") as archivo_completo: ,        ,         return leer(archivo_completo)
solicitar_valor,mensaje, minimo, maximo,app_matematica.py,       [Ayuda: Solicitar el ingreso de un valor y devolverlo, asegurando que,         estara entre el minimo y el maximo pasado por parametro],     valor = input(mensaje),     while (not valor.isdigit()) or ((int(valor) < minimo) or (int(valor) > maximo)):,         print("Error: Valor debe estar entre", minimo, "y", maximo),         valor = input(mensaje),         ,     return int(valor)
sacar_corchetes,cadena,consulta_de_funciones.py,    if cadena.endswith(" "):,         sin_corchetes = cadena.lstrip("[").rstrip("] "),     else:,         sin_corchetes = cadena.lstrip("[").rstrip("]"),     return sin_corchetes
potencia,base, exponente,lib_matematica.py,
organizar_datos,lista,Panel_General.py,       [Ayuda: Crea el diccionario inicial y contiene los campos Nombre,        de Funcion, Cantidad de Parametros, Canitdad de Lineas,     j = 0,     primeros_3 = {"Nombre de Funcion": lista[0] + lista[2], "Cantidad de Parametros": lista[1].count('('),,                   "Cantidad de Lineas": len(lista) - 3},     return primeros_3
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,    ,     ,     return sorted(diccionario.items(), key = lambda clave: clave[0], reverse = True)
mcm,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCM (minimo comun multiplo) entre los dos numeros,         recibidos. En caso de no existir, devolverá -1.,         Para el calculo se utiliza mcm(a,b) = (a*b)/MCD(a,b)],     return (nro_1 * nro_2)//mcd(nro_1, nro_2)
mcd,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCD entre los dos numeros recibidos, utilizando el,         metodo de Euclides. En caso de no existir MCD, devolverá -1.], ,     if abs(nro_1) < abs(nro_2):,         menor = abs(nro_1),         mayor = abs(nro_2),     else:,         menor = abs(nro_2),         mayor = abs(nro_1), ,         devovler = -1,     elif menor == 0:,         devolver = mayor,         dividendo = mayor,         divisor = menor,         resto = mayor % divisor, ,         while resto != 0:,             dividendo = divisor,             divisor = resto,             resto = dividendo % divisor, ,         devolver = divisor, ,     return devolver
main,,programa_principal.py,    ,     , ,     import m_generar_archivos_csv,     txt = 'programas.txt',     m_generar_archivos_csv.armar_csv_funciones(txt),     ,     import Informacion_por_desarrollador,     informacion,porcentaje = Informacion_por_desarrollador.capturo_datos(),     Informacion_por_desarrollador.participacion_info(informacion,porcentaje),     ,     return None
leer,archivo,m_generar_archivos_csv.py,    ,     ,     lineas = [linea.rstrip('\n') for linea in archivo],     ,     return lineas
impresiones ,contenido_a_mostrar,muestro_salida.py,    , ,     print(contenido_a_mostrar), ,     return None
generar_lista_total,dic,consulta_de_funciones.py,    lista_total = [[]],     for i in dic:,         ultima_lista = lista_total[-1],         if len(ultima_lista) < 5:,             ultima_lista.append(format(i, "<26s")),         else:,             lista_total.append([]),             ultima_lista = lista_total[-1],             ultima_lista.append(format(i, "<26s")),     if len(lista_total[-1]) < 5:,         for i in range(0, 5-len(lista_total[-1])):,             lista_total[-1].append(format(" ", "<26s")),     return lista_total
factorial,n,lib_matematica.py,       [Ayuda: Calcula el factorial de el numero recibido, que debe ser,         mayor o igual a cero], ,     resultado = 1,     for i in range(2, n+1):,         resultado = resultado * i, ,     return resultado
es_primo,valor,lib_matematica.py,       [Ayuda: Evlua si el numero recibido es primo o no, devolviendo True en,         caso de serlo, y False en caso contrario.], ,     devolver = True,     if valor <= 1:,         devolver = False,     else:,         divisor = 2,         while (((valor % divisor)!=0) and (divisor <= valor/2)):,             divisor += 1, ,         if divisor <= valor/2:,             devolver = False, ,         return devolver
contar_invocaciones,nombre_funcion, lista,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de Invoca,        ciones],     i = 0,     invocaciones_dict = {"Cantidad de Invocaciones": 0},     while i < len(lista):,         j = 4,         while j < len(lista[i]):,             if nombre_funcion in lista[i][j]:,                 invocaciones_dict["Cantidad de Invocaciones"] += 1,             j = j + 1,         i = i + 1,     return invocaciones_dict
contar_funciones,linea,contar_funciones.py,    cantidad_funciones = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": 0},     if linea.strip().startswith("if"):,         cantidad_funciones["if"] += 1,     elif linea.strip().startswith("while"):,         cantidad_funciones["while"] += 1,     elif linea.strip().startswith("for"):,         cantidad_funciones["for"] += 1,     elif linea.strip().startswith("return"):,         cantidad_funciones["returns"] += 1,     elif linea.strip().startswith("break"):,         cantidad_funciones["break"] += 1,     elif linea.strip().startswith("exit"):,         cantidad_funciones["exit"] += 1,     elif linea.strip().startswith("[Ayuda: ]"):,         cantidad_funciones["ayuda"] += 1,     return cantidad_funciones
contar_elementos_varios,lista, lista_comentarios,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de if, while,        for, returns, break, exit y ayuda,     cantidad_elementos = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": "NO"},     j = 4,     while j < len(lista):,         if lista[j].strip().startswith("if") or lista[j].strip().startswith(,             cantidad_elementos["if"] += 1,         elif lista[j].strip().startswith("while"):,             cantidad_elementos["while"] += 1,         elif lista[j].strip().startswith("for"):,             cantidad_elementos["for"] += 1,         elif lista[j].strip().startswith("return"):,             cantidad_elementos["returns"] += 1,         elif lista[j].strip().startswith("break"):,             cantidad_elementos["break"] += 1,         elif lista[j].strip().startswith("exit"):,             cantidad_elementos["exit"] += 1,         if lista_comentarios[2].strip().startswith("[Ayuda:"):,             cantidad_elementos["ayuda"] = "SI",         j = j + 1,     return cantidad_elementos
capturo_datos,,Informacion_por_desarrollador.py,    ,     (Nombres de las funciones, autor de la funcion , lineas por funcion y,     porcentaje de lineas del autor, sobre lineas totales del trabajo. ) ], ,     informacion_deseada = {},     ,     lineas_totales_por_autor = {}, ,     total_linea = 0, ,     with open("comentarios.csv","rt") as archivo_comentarios:,         ,         linea_archivos_comentarios = archivo_comentarios.readline(), ,         while linea_archivos_comentarios != "":,             ,             linea_a_lista_de_datos = linea_archivos_comentarios.split(","), ,             nombre_funcion = linea_a_lista_de_datos[0], ,             autor = linea_a_lista_de_datos[1].split(": ")[1].rstrip("]"), ,             informacion_deseada[nombre_funcion] = [autor,None], ,             linea_archivos_comentarios = archivo_comentarios.readline(), ,     with open ("fuente_unico.csv","rt") as archivo_fuente_unico:, ,         linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,         while linea_archivos_fuente_unico != "":, ,             linea_a_lista_de_datos = linea_archivos_fuente_unico.split(","),             ,             contador_lineas = 0, ,             funcion_actual = linea_a_lista_de_datos[0],             ,             total_linea += len(linea_a_lista_de_datos[3:]),             ,             contador_lineas = len(linea_a_lista_de_datos[3:]),             ,             for clave in informacion_deseada.keys():,                 ,                 if clave == funcion_actual:,                     informacion_deseada[clave][1] = contador_lineas,                     ,                     if informacion_deseada[clave][0] in lineas_totales_por_autor.keys():,                         lineas_totales_por_autor[informacion_deseada[clave][0]]+=contador_lineas,                     ,                     else:,                         lineas_totales_por_autor[informacion_deseada[clave][0]]=contador_lineas, ,             linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,     porcentajes ={}, ,     for clave in lineas_totales_por_autor.keys():,     ,         porcentajes[clave]=int((lineas_totales_por_autor[clave]/total_linea)*100), ,     ,     datos_finales = sorted(informacion_deseada.items(), key = lambda autor: autor[1][0]),     ,     return datos_finales,porcentajes
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,    ,         [Ayuda: Aquí se multiplica un espacio por un numero x,         El 8 es cantidad de caracateres que tiene una tabulacion,,         len(nom_fun) es la cantida de caracteres que tiene el nom_fun.,         Despues quiero que partir del carater 32 obtener la cant.lineas.,         Esta cuanta me asegura que el valor lineas_f este uno debajo del otro,,         multiplicando un str espacio la cantidad de veces nesesaria para cada caso. ],   ,     if 8 + len(nombre_funcion)<33:,         espacios = -1 * (8 + len(nombre_funcion) - 33),     else:,         espacios = 2, ,     return espacios  
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,    ,     ,     if nombre_archivo == 'fuente_unico.csv':,     ,         with open (nombre_archivo,"a") as codigo:,             ,             for clave in Estructura_de_datos:,                 ,                 nombre_funcion = clave[0],                 parametros = clave[1][0],                 modulo = clave[1][1],                 cuerpo = clave[1][2],                 ,                 funcion = "\n".join(cuerpo),             ,                 funcion = ", ".join(cuerpo),             ,                 codigo.write(nombre_funcion+","+parametros+","+modulo+","+funcion+"\n"),     ,     elif nombre_archivo == 'comentarios.csv':,         ,         with open (nombre_archivo,"a") as codigo:,             ,             for elementos in Estructura_de_datos:,                 ,                 nombre_funcion = elementos[0],                 nombre_autor = elementos[1][0],                 nombre_ayuda = elementos[1][1],                 resto = elementos[1][2], ,             ,                 funcion = ", ".join(resto),             ,                 codigo.write(nombre_funcion + "," + nombre_autor + "," + nombre_ayuda + "," + funcion + "\n"),     ,     return None
armar_diccionarios,,consulta_de_funciones.py,,     diccionario_fuente_unico = {},     diccionario_comentarios = {},     with open("fuente_unico.csv", "r") as fuente_unico:,         linea = fuente_unico.readline().rstrip("\n"),         while linea != "":,             datos = linea.split(","),             if len(datos) > 1:,                 nombre_funcion = datos[0],                 parametros = datos[1],                 modulo = datos[2],                 cuerpo = [datos[3] + i for i in datos[4:]],                 diccionario_fuente_unico[nombre_funcion.rstrip(" ")] = [parametros, modulo, cuerpo],                 linea = fuente_unico.readline().rstrip("\n"), ,     with open("comentarios.csv", "r") as comentarios:,         linea_comentarios = comentarios.readline().rstrip("\n"),         while linea_comentarios:,             datos2 = linea_comentarios.split(","),             nombre_funcion = datos2[0],             autor = datos2[1],             ayuda = datos2[2],             lista_comentarios = datos2[3:],             diccionario_comentarios[nombre_funcion.rstrip(" ")] = [autor, ayuda, lista_comentarios],             linea_comentarios = comentarios.readline().rstrip("\n"),         return diccionario_fuente_unico, diccionario_comentarios
armar_csv_funciones,archivo,m_generar_archivos_csv.py,    ,     ,     nombre_archivo = "fuente_unico.csv",     datos = {},     ,     modulos = abro_ar(archivo),     ,     for modulo in modulos:,         lineas = abro_ar(modulo), ,         for linea in lineas:,                   ,             if linea.startswith('def '):,                 funcion = linea,                 index_inicial = lineas.index(funcion) + 1,                 nombre_funcion = funcion.split('def ')[1].lstrip().split('(')[0],                 parametros = funcion.split('(')[1].lstrip().split(')')[0], ,             elif linea.strip().startswith('return'):,                 linea_return = linea,                 index_final = lineas.index(linea_return) + 1,                 cuerpo = lineas[index_inicial:index_final],                 cuerpo_sin_comment = armar_csv_comentarios(cuerpo,nombre_funcion),                 datos[nombre_funcion] = [parametros,modulo,cuerpo_sin_comment], ,     funciones_alfabeto = ordenar_alfabeticamente(datos),   ,     return modulo_csv.armo_csv(funciones_alfabeto,nombre_archivo)
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,    ,     ,     comentario_triple = '\"\"\"',     nombre_archivo = 'comentarios.csv',     autor = "[Autor:",     ayuda = "[Ayuda:",     nombre_autor = "",     nombre_ayuda = "",     resto = []   ,     datos_comentarios = {}, ,     lista = lista_cuerpo    ,     resto = [j for j in lineas_comentadas if autor not in j and ayuda not in j],     cuerpo_sin_comentarios = [x for x in lista if x not in lineas_comentadas],     ,     for comentarios in lineas_comentadas:,         if autor in comentarios:,             nombre_autor = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],         elif ayuda in comentarios:,             nombre_ayuda = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],             ,             datos_comentarios[nombre_funcion] = [nombre_autor,nombre_ayuda,resto],             ,     comentarios_alfabeto = ordenar_alfabeticamente(datos_comentarios),     ,     modulo_csv.armo_csv(comentarios_alfabeto,nombre_archivo),     ,     return cuerpo_sin_comentarios
abro_ar,archivo,m_generar_archivos_csv.py,    , , ,     with open(archivo, encoding="utf8") as archivo_completo: ,        ,         return leer(archivo_completo)
solicitar_valor,mensaje, minimo, maximo,app_matematica.py,       [Ayuda: Solicitar el ingreso de un valor y devolverlo, asegurando que,         estara entre el minimo y el maximo pasado por parametro],     valor = input(mensaje),     while (not valor.isdigit()) or ((int(valor) < minimo) or (int(valor) > maximo)):,         print("Error: Valor debe estar entre", minimo, "y", maximo),         valor = input(mensaje),         ,     return int(valor)
sacar_corchetes,cadena,consulta_de_funciones.py,    if cadena.endswith(" "):,         sin_corchetes = cadena.lstrip("[").rstrip("] "),     else:,         sin_corchetes = cadena.lstrip("[").rstrip("]"),     return sin_corchetes
potencia,base, exponente,lib_matematica.py,
organizar_datos,lista,Panel_General.py,       [Ayuda: Crea el diccionario inicial y contiene los campos Nombre,        de Funcion, Cantidad de Parametros, Canitdad de Lineas,     j = 0,     primeros_3 = {"Nombre de Funcion": lista[0] + lista[2], "Cantidad de Parametros": lista[1].count('('),,                   "Cantidad de Lineas": len(lista) - 3},     return primeros_3
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,    ,     ,     return sorted(diccionario.items(), key = lambda clave: clave[0], reverse = True)
mcm,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCM (minimo comun multiplo) entre los dos numeros,         recibidos. En caso de no existir, devolverá -1.,         Para el calculo se utiliza mcm(a,b) = (a*b)/MCD(a,b)],     return (nro_1 * nro_2)//mcd(nro_1, nro_2)
mcd,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCD entre los dos numeros recibidos, utilizando el,         metodo de Euclides. En caso de no existir MCD, devolverá -1.], ,     if abs(nro_1) < abs(nro_2):,         menor = abs(nro_1),         mayor = abs(nro_2),     else:,         menor = abs(nro_2),         mayor = abs(nro_1), ,         devovler = -1,     elif menor == 0:,         devolver = mayor,         dividendo = mayor,         divisor = menor,         resto = mayor % divisor, ,         while resto != 0:,             dividendo = divisor,             divisor = resto,             resto = dividendo % divisor, ,         devolver = divisor, ,     return devolver
main,,programa_principal.py,    ,     , ,     import m_generar_archivos_csv,     txt = 'programas.txt',     m_generar_archivos_csv.armar_csv_funciones(txt),     ,     import Informacion_por_desarrollador,     informacion,porcentaje = Informacion_por_desarrollador.capturo_datos(),     Informacion_por_desarrollador.participacion_info(informacion,porcentaje),     ,     return None
leer,archivo,m_generar_archivos_csv.py,    ,     ,     lineas = [linea.rstrip('\n') for linea in archivo],     ,     return lineas
impresiones ,contenido_a_mostrar,muestro_salida.py,    , ,     print(contenido_a_mostrar), ,     return None
generar_lista_total,dic,consulta_de_funciones.py,    lista_total = [[]],     for i in dic:,         ultima_lista = lista_total[-1],         if len(ultima_lista) < 5:,             ultima_lista.append(format(i, "<26s")),         else:,             lista_total.append([]),             ultima_lista = lista_total[-1],             ultima_lista.append(format(i, "<26s")),     if len(lista_total[-1]) < 5:,         for i in range(0, 5-len(lista_total[-1])):,             lista_total[-1].append(format(" ", "<26s")),     return lista_total
factorial,n,lib_matematica.py,       [Ayuda: Calcula el factorial de el numero recibido, que debe ser,         mayor o igual a cero], ,     resultado = 1,     for i in range(2, n+1):,         resultado = resultado * i, ,     return resultado
es_primo,valor,lib_matematica.py,       [Ayuda: Evlua si el numero recibido es primo o no, devolviendo True en,         caso de serlo, y False en caso contrario.], ,     devolver = True,     if valor <= 1:,         devolver = False,     else:,         divisor = 2,         while (((valor % divisor)!=0) and (divisor <= valor/2)):,             divisor += 1, ,         if divisor <= valor/2:,             devolver = False, ,         return devolver
contar_invocaciones,nombre_funcion, lista,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de Invoca,        ciones],     i = 0,     invocaciones_dict = {"Cantidad de Invocaciones": 0},     while i < len(lista):,         j = 4,         while j < len(lista[i]):,             if nombre_funcion in lista[i][j]:,                 invocaciones_dict["Cantidad de Invocaciones"] += 1,             j = j + 1,         i = i + 1,     return invocaciones_dict
contar_funciones,linea,contar_funciones.py,    cantidad_funciones = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": 0},     if linea.strip().startswith("if"):,         cantidad_funciones["if"] += 1,     elif linea.strip().startswith("while"):,         cantidad_funciones["while"] += 1,     elif linea.strip().startswith("for"):,         cantidad_funciones["for"] += 1,     elif linea.strip().startswith("return"):,         cantidad_funciones["returns"] += 1,     elif linea.strip().startswith("break"):,         cantidad_funciones["break"] += 1,     elif linea.strip().startswith("exit"):,         cantidad_funciones["exit"] += 1,     elif linea.strip().startswith("[Ayuda: ]"):,         cantidad_funciones["ayuda"] += 1,     return cantidad_funciones
contar_elementos_varios,lista, lista_comentarios,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de if, while,        for, returns, break, exit y ayuda,     cantidad_elementos = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": "NO"},     j = 4,     while j < len(lista):,         if lista[j].strip().startswith("if") or lista[j].strip().startswith(,             cantidad_elementos["if"] += 1,         elif lista[j].strip().startswith("while"):,             cantidad_elementos["while"] += 1,         elif lista[j].strip().startswith("for"):,             cantidad_elementos["for"] += 1,         elif lista[j].strip().startswith("return"):,             cantidad_elementos["returns"] += 1,         elif lista[j].strip().startswith("break"):,             cantidad_elementos["break"] += 1,         elif lista[j].strip().startswith("exit"):,             cantidad_elementos["exit"] += 1,         if lista_comentarios[2].strip().startswith("[Ayuda:"):,             cantidad_elementos["ayuda"] = "SI",         j = j + 1,     return cantidad_elementos
capturo_datos,,Informacion_por_desarrollador.py,    ,     (Nombres de las funciones, autor de la funcion , lineas por funcion y,     porcentaje de lineas del autor, sobre lineas totales del trabajo. ) ], ,     informacion_deseada = {},     ,     lineas_totales_por_autor = {}, ,     total_linea = 0, ,     with open("comentarios.csv","rt") as archivo_comentarios:,         ,         linea_archivos_comentarios = archivo_comentarios.readline(), ,         while linea_archivos_comentarios != "":,             ,             linea_a_lista_de_datos = linea_archivos_comentarios.split(","), ,             nombre_funcion = linea_a_lista_de_datos[0], ,             autor = linea_a_lista_de_datos[1].split(": ")[1].rstrip("]"), ,             informacion_deseada[nombre_funcion] = [autor,None], ,             linea_archivos_comentarios = archivo_comentarios.readline(), ,     with open ("fuente_unico.csv","rt") as archivo_fuente_unico:, ,         linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,         while linea_archivos_fuente_unico != "":, ,             linea_a_lista_de_datos = linea_archivos_fuente_unico.split(","),             ,             contador_lineas = 0, ,             funcion_actual = linea_a_lista_de_datos[0],             ,             total_linea += len(linea_a_lista_de_datos[3:]),             ,             contador_lineas = len(linea_a_lista_de_datos[3:]),             ,             for clave in informacion_deseada.keys():,                 ,                 if clave == funcion_actual:,                     informacion_deseada[clave][1] = contador_lineas,                     ,                     if informacion_deseada[clave][0] in lineas_totales_por_autor.keys():,                         lineas_totales_por_autor[informacion_deseada[clave][0]]+=contador_lineas,                     ,                     else:,                         lineas_totales_por_autor[informacion_deseada[clave][0]]=contador_lineas, ,             linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,     porcentajes ={}, ,     for clave in lineas_totales_por_autor.keys():,     ,         porcentajes[clave]=int((lineas_totales_por_autor[clave]/total_linea)*100), ,     ,     datos_finales = sorted(informacion_deseada.items(), key = lambda autor: autor[1][0]),     ,     return datos_finales,porcentajes
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,    ,         [Ayuda: Aquí se multiplica un espacio por un numero x,         El 8 es cantidad de caracateres que tiene una tabulacion,,         len(nom_fun) es la cantida de caracteres que tiene el nom_fun.,         Despues quiero que partir del carater 32 obtener la cant.lineas.,         Esta cuanta me asegura que el valor lineas_f este uno debajo del otro,,         multiplicando un str espacio la cantidad de veces nesesaria para cada caso. ],   ,     if 8 + len(nombre_funcion)<33:,         espacios = -1 * (8 + len(nombre_funcion) - 33),     else:,         espacios = 2, ,     return espacios  
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,    ,     ,     if nombre_archivo == 'fuente_unico.csv':,     ,         with open (nombre_archivo,"a") as codigo:,             ,             for clave in Estructura_de_datos:,                 ,                 nombre_funcion = clave[0],                 parametros = clave[1][0],                 modulo = clave[1][1],                 cuerpo = clave[1][2],                 ,                 funcion = "\n".join(cuerpo),             ,                 funcion = ", ".join(cuerpo),             ,                 codigo.write(nombre_funcion+","+parametros+","+modulo+","+funcion+"\n"),     ,     elif nombre_archivo == 'comentarios.csv':,         ,         with open (nombre_archivo,"a") as codigo:,             ,             for elementos in Estructura_de_datos:,                 ,                 nombre_funcion = elementos[0],                 nombre_autor = elementos[1][0],                 nombre_ayuda = elementos[1][1],                 resto = elementos[1][2], ,             ,                 funcion = ", ".join(resto),             ,                 codigo.write(nombre_funcion + "," + nombre_autor + "," + nombre_ayuda + "," + funcion + "\n"),     ,     return None
armar_diccionarios,,consulta_de_funciones.py,,     diccionario_fuente_unico = {},     diccionario_comentarios = {},     with open("fuente_unico.csv", "r") as fuente_unico:,         linea = fuente_unico.readline().rstrip("\n"),         while linea != "":,             datos = linea.split(","),             if len(datos) > 1:,                 nombre_funcion = datos[0],                 parametros = datos[1],                 modulo = datos[2],                 cuerpo = [datos[3] + i for i in datos[4:]],                 diccionario_fuente_unico[nombre_funcion.rstrip(" ")] = [parametros, modulo, cuerpo],                 linea = fuente_unico.readline().rstrip("\n"), ,     with open("comentarios.csv", "r") as comentarios:,         linea_comentarios = comentarios.readline().rstrip("\n"),         while linea_comentarios:,             datos2 = linea_comentarios.split(","),             nombre_funcion = datos2[0],             autor = datos2[1],             ayuda = datos2[2],             lista_comentarios = datos2[3:],             diccionario_comentarios[nombre_funcion.rstrip(" ")] = [autor, ayuda, lista_comentarios],             linea_comentarios = comentarios.readline().rstrip("\n"),         return diccionario_fuente_unico, diccionario_comentarios
armar_csv_funciones,archivo,m_generar_archivos_csv.py,    ,     ,     nombre_archivo = "fuente_unico.csv",     datos = {},     ,     modulos = abro_ar(archivo),     ,     for modulo in modulos:,         lineas = abro_ar(modulo), ,         for linea in lineas:,                   ,             if linea.startswith('def '):,                 funcion = linea,                 index_inicial = lineas.index(funcion) + 1,                 nombre_funcion = funcion.split('def ')[1].lstrip().split('(')[0],                 parametros = funcion.split('(')[1].lstrip().split(')')[0], ,             elif linea.strip().startswith('return'):,                 linea_return = linea,                 index_final = lineas.index(linea_return) + 1,                 cuerpo = lineas[index_inicial:index_final],                 cuerpo_sin_comment = armar_csv_comentarios(cuerpo,nombre_funcion),                 datos[nombre_funcion] = [parametros,modulo,cuerpo_sin_comment], ,     funciones_alfabeto = ordenar_alfabeticamente(datos),   ,     return modulo_csv.armo_csv(funciones_alfabeto,nombre_archivo)
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,    ,     ,     comentario_triple = '\"\"\"',     nombre_archivo = 'comentarios.csv',     autor = "[Autor:",     ayuda = "[Ayuda:",     nombre_autor = "",     nombre_ayuda = "",     resto = []   ,     datos_comentarios = {}, ,     lista = lista_cuerpo    ,     resto = [j for j in lineas_comentadas if autor not in j and ayuda not in j],     cuerpo_sin_comentarios = [x for x in lista if x not in lineas_comentadas],     ,     for comentarios in lineas_comentadas:,         if autor in comentarios:,             nombre_autor = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],         elif ayuda in comentarios:,             nombre_ayuda = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],             ,             datos_comentarios[nombre_funcion] = [nombre_autor,nombre_ayuda,resto],             ,     comentarios_alfabeto = ordenar_alfabeticamente(datos_comentarios),     ,     modulo_csv.armo_csv(comentarios_alfabeto,nombre_archivo),     ,     return cuerpo_sin_comentarios
abro_ar,archivo,m_generar_archivos_csv.py,    , , ,     with open(archivo, encoding="utf8") as archivo_completo: ,        ,         return leer(archivo_completo)
solicitar_valor,mensaje, minimo, maximo,app_matematica.py,       [Ayuda: Solicitar el ingreso de un valor y devolverlo, asegurando que,         estara entre el minimo y el maximo pasado por parametro],     valor = input(mensaje),     while (not valor.isdigit()) or ((int(valor) < minimo) or (int(valor) > maximo)):,         print("Error: Valor debe estar entre", minimo, "y", maximo),         valor = input(mensaje),         ,     return int(valor)
sacar_corchetes,cadena,consulta_de_funciones.py,    if cadena.endswith(" "):,         sin_corchetes = cadena.lstrip("[").rstrip("] "),     else:,         sin_corchetes = cadena.lstrip("[").rstrip("]"),     return sin_corchetes
potencia,base, exponente,lib_matematica.py,
organizar_datos,lista,Panel_General.py,       [Ayuda: Crea el diccionario inicial y contiene los campos Nombre,        de Funcion, Cantidad de Parametros, Canitdad de Lineas,     j = 0,     primeros_3 = {"Nombre de Funcion": lista[0] + lista[2], "Cantidad de Parametros": lista[1].count('('),,                   "Cantidad de Lineas": len(lista) - 3},     return primeros_3
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,    ,     ,     return sorted(diccionario.items(), key = lambda clave: clave[0], reverse = True)
mcm,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCM (minimo comun multiplo) entre los dos numeros,         recibidos. En caso de no existir, devolverá -1.,         Para el calculo se utiliza mcm(a,b) = (a*b)/MCD(a,b)],     return (nro_1 * nro_2)//mcd(nro_1, nro_2)
mcd,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCD entre los dos numeros recibidos, utilizando el,         metodo de Euclides. En caso de no existir MCD, devolverá -1.], ,     if abs(nro_1) < abs(nro_2):,         menor = abs(nro_1),         mayor = abs(nro_2),     else:,         menor = abs(nro_2),         mayor = abs(nro_1), ,         devovler = -1,     elif menor == 0:,         devolver = mayor,         dividendo = mayor,         divisor = menor,         resto = mayor % divisor, ,         while resto != 0:,             dividendo = divisor,             divisor = resto,             resto = dividendo % divisor, ,         devolver = divisor, ,     return devolver
main,,programa_principal.py,    ,     , ,     import m_generar_archivos_csv,     txt = 'programas.txt',     m_generar_archivos_csv.armar_csv_funciones(txt),     ,     import Informacion_por_desarrollador,     informacion,porcentaje = Informacion_por_desarrollador.capturo_datos(),     Informacion_por_desarrollador.participacion_info(informacion,porcentaje),     ,     return None
leer,archivo,m_generar_archivos_csv.py,    ,     ,     lineas = [linea.rstrip('\n') for linea in archivo],     ,     return lineas
impresiones ,contenido_a_mostrar,muestro_salida.py,    , ,     print(contenido_a_mostrar), ,     return None
generar_lista_total,dic,consulta_de_funciones.py,    lista_total = [[]],     for i in dic:,         ultima_lista = lista_total[-1],         if len(ultima_lista) < 5:,             ultima_lista.append(format(i, "<26s")),         else:,             lista_total.append([]),             ultima_lista = lista_total[-1],             ultima_lista.append(format(i, "<26s")),     if len(lista_total[-1]) < 5:,         for i in range(0, 5-len(lista_total[-1])):,             lista_total[-1].append(format(" ", "<26s")),     return lista_total
factorial,n,lib_matematica.py,       [Ayuda: Calcula el factorial de el numero recibido, que debe ser,         mayor o igual a cero], ,     resultado = 1,     for i in range(2, n+1):,         resultado = resultado * i, ,     return resultado
es_primo,valor,lib_matematica.py,       [Ayuda: Evlua si el numero recibido es primo o no, devolviendo True en,         caso de serlo, y False en caso contrario.], ,     devolver = True,     if valor <= 1:,         devolver = False,     else:,         divisor = 2,         while (((valor % divisor)!=0) and (divisor <= valor/2)):,             divisor += 1, ,         if divisor <= valor/2:,             devolver = False, ,         return devolver
contar_invocaciones,nombre_funcion, lista,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de Invoca,        ciones],     i = 0,     invocaciones_dict = {"Cantidad de Invocaciones": 0},     while i < len(lista):,         j = 4,         while j < len(lista[i]):,             if nombre_funcion in lista[i][j]:,                 invocaciones_dict["Cantidad de Invocaciones"] += 1,             j = j + 1,         i = i + 1,     return invocaciones_dict
contar_funciones,linea,contar_funciones.py,    cantidad_funciones = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": 0},     if linea.strip().startswith("if"):,         cantidad_funciones["if"] += 1,     elif linea.strip().startswith("while"):,         cantidad_funciones["while"] += 1,     elif linea.strip().startswith("for"):,         cantidad_funciones["for"] += 1,     elif linea.strip().startswith("return"):,         cantidad_funciones["returns"] += 1,     elif linea.strip().startswith("break"):,         cantidad_funciones["break"] += 1,     elif linea.strip().startswith("exit"):,         cantidad_funciones["exit"] += 1,     elif linea.strip().startswith("[Ayuda: ]"):,         cantidad_funciones["ayuda"] += 1,     return cantidad_funciones
contar_elementos_varios,lista, lista_comentarios,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de if, while,        for, returns, break, exit y ayuda,     cantidad_elementos = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": "NO"},     j = 4,     while j < len(lista):,         if lista[j].strip().startswith("if") or lista[j].strip().startswith(,             cantidad_elementos["if"] += 1,         elif lista[j].strip().startswith("while"):,             cantidad_elementos["while"] += 1,         elif lista[j].strip().startswith("for"):,             cantidad_elementos["for"] += 1,         elif lista[j].strip().startswith("return"):,             cantidad_elementos["returns"] += 1,         elif lista[j].strip().startswith("break"):,             cantidad_elementos["break"] += 1,         elif lista[j].strip().startswith("exit"):,             cantidad_elementos["exit"] += 1,         if lista_comentarios[2].strip().startswith("[Ayuda:"):,             cantidad_elementos["ayuda"] = "SI",         j = j + 1,     return cantidad_elementos
capturo_datos,,Informacion_por_desarrollador.py,    ,     (Nombres de las funciones, autor de la funcion , lineas por funcion y,     porcentaje de lineas del autor, sobre lineas totales del trabajo. ) ], ,     informacion_deseada = {},     ,     lineas_totales_por_autor = {}, ,     total_linea = 0, ,     with open("comentarios.csv","rt") as archivo_comentarios:,         ,         linea_archivos_comentarios = archivo_comentarios.readline(), ,         while linea_archivos_comentarios != "":,             ,             linea_a_lista_de_datos = linea_archivos_comentarios.split(","), ,             nombre_funcion = linea_a_lista_de_datos[0], ,             autor = linea_a_lista_de_datos[1].split(": ")[1].rstrip("]"), ,             informacion_deseada[nombre_funcion] = [autor,None], ,             linea_archivos_comentarios = archivo_comentarios.readline(), ,     with open ("fuente_unico.csv","rt") as archivo_fuente_unico:, ,         linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,         while linea_archivos_fuente_unico != "":, ,             linea_a_lista_de_datos = linea_archivos_fuente_unico.split(","),             ,             contador_lineas = 0, ,             funcion_actual = linea_a_lista_de_datos[0],             ,             total_linea += len(linea_a_lista_de_datos[3:]),             ,             contador_lineas = len(linea_a_lista_de_datos[3:]),             ,             for clave in informacion_deseada.keys():,                 ,                 if clave == funcion_actual:,                     informacion_deseada[clave][1] = contador_lineas,                     ,                     if informacion_deseada[clave][0] in lineas_totales_por_autor.keys():,                         lineas_totales_por_autor[informacion_deseada[clave][0]]+=contador_lineas,                     ,                     else:,                         lineas_totales_por_autor[informacion_deseada[clave][0]]=contador_lineas, ,             linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,     porcentajes ={}, ,     for clave in lineas_totales_por_autor.keys():,     ,         porcentajes[clave]=int((lineas_totales_por_autor[clave]/total_linea)*100), ,     ,     datos_finales = sorted(informacion_deseada.items(), key = lambda autor: autor[1][0]),     ,     return datos_finales,porcentajes
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,    ,         [Ayuda: Aquí se multiplica un espacio por un numero x,         El 8 es cantidad de caracateres que tiene una tabulacion,,         len(nom_fun) es la cantida de caracteres que tiene el nom_fun.,         Despues quiero que partir del carater 32 obtener la cant.lineas.,         Esta cuanta me asegura que el valor lineas_f este uno debajo del otro,,         multiplicando un str espacio la cantidad de veces nesesaria para cada caso. ],   ,     if 8 + len(nombre_funcion)<33:,         espacios = -1 * (8 + len(nombre_funcion) - 33),     else:,         espacios = 2, ,     return espacios  
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,    ,     ,     if nombre_archivo == 'fuente_unico.csv':,     ,         with open (nombre_archivo,"a") as codigo:,             ,             for clave in Estructura_de_datos:,                 ,                 nombre_funcion = clave[0],                 parametros = clave[1][0],                 modulo = clave[1][1],                 cuerpo = clave[1][2],                 ,                 funcion = "\n".join(cuerpo),             ,                 funcion = ", ".join(cuerpo),             ,                 codigo.write(nombre_funcion+","+parametros+","+modulo+","+funcion+"\n"),     ,     elif nombre_archivo == 'comentarios.csv':,         ,         with open (nombre_archivo,"a") as codigo:,             ,             for elementos in Estructura_de_datos:,                 ,                 nombre_funcion = elementos[0],                 nombre_autor = elementos[1][0],                 nombre_ayuda = elementos[1][1],                 resto = elementos[1][2], ,             ,                 funcion = ", ".join(resto),             ,                 codigo.write(nombre_funcion + "," + nombre_autor + "," + nombre_ayuda + "," + funcion + "\n"),     ,     return None
armar_diccionarios,,consulta_de_funciones.py,,     diccionario_fuente_unico = {},     diccionario_comentarios = {},     with open("fuente_unico.csv", "r") as fuente_unico:,         linea = fuente_unico.readline().rstrip("\n"),         while linea != "":,             datos = linea.split(","),             if len(datos) > 1:,                 nombre_funcion = datos[0],                 parametros = datos[1],                 modulo = datos[2],                 cuerpo = [datos[3] + i for i in datos[4:]],                 diccionario_fuente_unico[nombre_funcion.rstrip(" ")] = [parametros, modulo, cuerpo],                 linea = fuente_unico.readline().rstrip("\n"), ,     with open("comentarios.csv", "r") as comentarios:,         linea_comentarios = comentarios.readline().rstrip("\n"),         while linea_comentarios:,             datos2 = linea_comentarios.split(","),             nombre_funcion = datos2[0],             autor = datos2[1],             ayuda = datos2[2],             lista_comentarios = datos2[3:],             diccionario_comentarios[nombre_funcion.rstrip(" ")] = [autor, ayuda, lista_comentarios],             linea_comentarios = comentarios.readline().rstrip("\n"),         return diccionario_fuente_unico, diccionario_comentarios
armar_csv_funciones,archivo,m_generar_archivos_csv.py,    ,     ,     nombre_archivo = "fuente_unico.csv",     datos = {},     ,     modulos = abro_ar(archivo),     ,     for modulo in modulos:,         lineas = abro_ar(modulo), ,         for linea in lineas:,                   ,             if linea.startswith('def '):,                 funcion = linea,                 index_inicial = lineas.index(funcion) + 1,                 nombre_funcion = funcion.split('def ')[1].lstrip().split('(')[0],                 parametros = funcion.split('(')[1].lstrip().split(')')[0], ,             elif linea.strip().startswith('return'):,                 linea_return = linea,                 index_final = lineas.index(linea_return) + 1,                 cuerpo = lineas[index_inicial:index_final],                 cuerpo_sin_comment = armar_csv_comentarios(cuerpo,nombre_funcion),                 datos[nombre_funcion] = [parametros,modulo,cuerpo_sin_comment], ,     funciones_alfabeto = ordenar_alfabeticamente(datos),   ,     return modulo_csv.armo_csv(funciones_alfabeto,nombre_archivo)
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,    ,     ,     comentario_triple = '\"\"\"',     nombre_archivo = 'comentarios.csv',     autor = "[Autor:",     ayuda = "[Ayuda:",     nombre_autor = "",     nombre_ayuda = "",     resto = []   ,     datos_comentarios = {}, ,     lista = lista_cuerpo    ,     resto = [j for j in lineas_comentadas if autor not in j and ayuda not in j],     cuerpo_sin_comentarios = [x for x in lista if x not in lineas_comentadas],     ,     for comentarios in lineas_comentadas:,         if autor in comentarios:,             nombre_autor = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],         elif ayuda in comentarios:,             nombre_ayuda = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],             ,             datos_comentarios[nombre_funcion] = [nombre_autor,nombre_ayuda,resto],             ,     comentarios_alfabeto = ordenar_alfabeticamente(datos_comentarios),     ,     modulo_csv.armo_csv(comentarios_alfabeto,nombre_archivo),     ,     return cuerpo_sin_comentarios
abro_ar,archivo,m_generar_archivos_csv.py,    , , ,     with open(archivo, encoding="utf8") as archivo_completo: ,        ,         return leer(archivo_completo)
solicitar_valor,mensaje, minimo, maximo,app_matematica.py,       [Ayuda: Solicitar el ingreso de un valor y devolverlo, asegurando que,         estara entre el minimo y el maximo pasado por parametro],     valor = input(mensaje),     while (not valor.isdigit()) or ((int(valor) < minimo) or (int(valor) > maximo)):,         print("Error: Valor debe estar entre", minimo, "y", maximo),         valor = input(mensaje),         ,     return int(valor)
sacar_corchetes,cadena,consulta_de_funciones.py,    if cadena.endswith(" "):,         sin_corchetes = cadena.lstrip("[").rstrip("] "),     else:,         sin_corchetes = cadena.lstrip("[").rstrip("]"),     return sin_corchetes
potencia,base, exponente,lib_matematica.py,
organizar_datos,lista,Panel_General.py,       [Ayuda: Crea el diccionario inicial y contiene los campos Nombre,        de Funcion, Cantidad de Parametros, Canitdad de Lineas,     j = 0,     primeros_3 = {"Nombre de Funcion": lista[0] + lista[2], "Cantidad de Parametros": lista[1].count('('),,                   "Cantidad de Lineas": len(lista) - 3},     return primeros_3
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,    ,     ,     return sorted(diccionario.items(), key = lambda clave: clave[0], reverse = True)
mcm,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCM (minimo comun multiplo) entre los dos numeros,         recibidos. En caso de no existir, devolverá -1.,         Para el calculo se utiliza mcm(a,b) = (a*b)/MCD(a,b)],     return (nro_1 * nro_2)//mcd(nro_1, nro_2)
mcd,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCD entre los dos numeros recibidos, utilizando el,         metodo de Euclides. En caso de no existir MCD, devolverá -1.], ,     if abs(nro_1) < abs(nro_2):,         menor = abs(nro_1),         mayor = abs(nro_2),     else:,         menor = abs(nro_2),         mayor = abs(nro_1), ,         devovler = -1,     elif menor == 0:,         devolver = mayor,         dividendo = mayor,         divisor = menor,         resto = mayor % divisor, ,         while resto != 0:,             dividendo = divisor,             divisor = resto,             resto = dividendo % divisor, ,         devolver = divisor, ,     return devolver
main,,programa_principal.py,    ,     , ,     import m_generar_archivos_csv,     txt = 'programas.txt',     m_generar_archivos_csv.armar_csv_funciones(txt),     ,     import Informacion_por_desarrollador,     informacion,porcentaje = Informacion_por_desarrollador.capturo_datos(),     Informacion_por_desarrollador.participacion_info(informacion,porcentaje),     ,     return None
leer,archivo,m_generar_archivos_csv.py,    ,     ,     lineas = [linea.rstrip('\n') for linea in archivo],     ,     return lineas
impresiones ,contenido_a_mostrar,muestro_salida.py,    , ,     print(contenido_a_mostrar), ,     return None
generar_lista_total,dic,consulta_de_funciones.py,    lista_total = [[]],     for i in dic:,         ultima_lista = lista_total[-1],         if len(ultima_lista) < 5:,             ultima_lista.append(format(i, "<26s")),         else:,             lista_total.append([]),             ultima_lista = lista_total[-1],             ultima_lista.append(format(i, "<26s")),     if len(lista_total[-1]) < 5:,         for i in range(0, 5-len(lista_total[-1])):,             lista_total[-1].append(format(" ", "<26s")),     return lista_total
factorial,n,lib_matematica.py,       [Ayuda: Calcula el factorial de el numero recibido, que debe ser,         mayor o igual a cero], ,     resultado = 1,     for i in range(2, n+1):,         resultado = resultado * i, ,     return resultado
es_primo,valor,lib_matematica.py,       [Ayuda: Evlua si el numero recibido es primo o no, devolviendo True en,         caso de serlo, y False en caso contrario.], ,     devolver = True,     if valor <= 1:,         devolver = False,     else:,         divisor = 2,         while (((valor % divisor)!=0) and (divisor <= valor/2)):,             divisor += 1, ,         if divisor <= valor/2:,             devolver = False, ,         return devolver
contar_invocaciones,nombre_funcion, lista,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de Invoca,        ciones],     i = 0,     invocaciones_dict = {"Cantidad de Invocaciones": 0},     while i < len(lista):,         j = 4,         while j < len(lista[i]):,             if nombre_funcion in lista[i][j]:,                 invocaciones_dict["Cantidad de Invocaciones"] += 1,             j = j + 1,         i = i + 1,     return invocaciones_dict
contar_funciones,linea,contar_funciones.py,    cantidad_funciones = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": 0},     if linea.strip().startswith("if"):,         cantidad_funciones["if"] += 1,     elif linea.strip().startswith("while"):,         cantidad_funciones["while"] += 1,     elif linea.strip().startswith("for"):,         cantidad_funciones["for"] += 1,     elif linea.strip().startswith("return"):,         cantidad_funciones["returns"] += 1,     elif linea.strip().startswith("break"):,         cantidad_funciones["break"] += 1,     elif linea.strip().startswith("exit"):,         cantidad_funciones["exit"] += 1,     elif linea.strip().startswith("[Ayuda: ]"):,         cantidad_funciones["ayuda"] += 1,     return cantidad_funciones
contar_elementos_varios,lista, lista_comentarios,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de if, while,        for, returns, break, exit y ayuda,     cantidad_elementos = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": "NO"},     j = 4,     while j < len(lista):,         if lista[j].strip().startswith("if") or lista[j].strip().startswith(,             cantidad_elementos["if"] += 1,         elif lista[j].strip().startswith("while"):,             cantidad_elementos["while"] += 1,         elif lista[j].strip().startswith("for"):,             cantidad_elementos["for"] += 1,         elif lista[j].strip().startswith("return"):,             cantidad_elementos["returns"] += 1,         elif lista[j].strip().startswith("break"):,             cantidad_elementos["break"] += 1,         elif lista[j].strip().startswith("exit"):,             cantidad_elementos["exit"] += 1,         if lista_comentarios[2].strip().startswith("[Ayuda:"):,             cantidad_elementos["ayuda"] = "SI",         j = j + 1,     return cantidad_elementos
capturo_datos,,Informacion_por_desarrollador.py,    ,     (Nombres de las funciones, autor de la funcion , lineas por funcion y,     porcentaje de lineas del autor, sobre lineas totales del trabajo. ) ], ,     informacion_deseada = {},     ,     lineas_totales_por_autor = {}, ,     total_linea = 0, ,     with open("comentarios.csv","rt") as archivo_comentarios:,         ,         linea_archivos_comentarios = archivo_comentarios.readline(), ,         while linea_archivos_comentarios != "":,             ,             linea_a_lista_de_datos = linea_archivos_comentarios.split(","), ,             nombre_funcion = linea_a_lista_de_datos[0], ,             autor = linea_a_lista_de_datos[1].split(": ")[1].rstrip("]"), ,             informacion_deseada[nombre_funcion] = [autor,None], ,             linea_archivos_comentarios = archivo_comentarios.readline(), ,     with open ("fuente_unico.csv","rt") as archivo_fuente_unico:, ,         linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,         while linea_archivos_fuente_unico != "":, ,             linea_a_lista_de_datos = linea_archivos_fuente_unico.split(","),             ,             contador_lineas = 0, ,             funcion_actual = linea_a_lista_de_datos[0],             ,             total_linea += len(linea_a_lista_de_datos[3:]),             ,             contador_lineas = len(linea_a_lista_de_datos[3:]),             ,             for clave in informacion_deseada.keys():,                 ,                 if clave == funcion_actual:,                     informacion_deseada[clave][1] = contador_lineas,                     ,                     if informacion_deseada[clave][0] in lineas_totales_por_autor.keys():,                         lineas_totales_por_autor[informacion_deseada[clave][0]]+=contador_lineas,                     ,                     else:,                         lineas_totales_por_autor[informacion_deseada[clave][0]]=contador_lineas, ,             linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,     porcentajes ={}, ,     for clave in lineas_totales_por_autor.keys():,     ,         porcentajes[clave]=int((lineas_totales_por_autor[clave]/total_linea)*100), ,     ,     datos_finales = sorted(informacion_deseada.items(), key = lambda autor: autor[1][0]),     ,     return datos_finales,porcentajes
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,    ,         [Ayuda: Aquí se multiplica un espacio por un numero x,         El 8 es cantidad de caracateres que tiene una tabulacion,,         len(nom_fun) es la cantida de caracteres que tiene el nom_fun.,         Despues quiero que partir del carater 32 obtener la cant.lineas.,         Esta cuanta me asegura que el valor lineas_f este uno debajo del otro,,         multiplicando un str espacio la cantidad de veces nesesaria para cada caso. ],   ,     if 8 + len(nombre_funcion)<33:,         espacios = -1 * (8 + len(nombre_funcion) - 33),     else:,         espacios = 2, ,     return espacios  
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,    ,     ,     if nombre_archivo == 'fuente_unico.csv':,     ,         with open (nombre_archivo,"a") as codigo:,             ,             for clave in Estructura_de_datos:,                 ,                 nombre_funcion = clave[0],                 parametros = clave[1][0],                 modulo = clave[1][1],                 cuerpo = clave[1][2],                 ,                 funcion = "\n".join(cuerpo),             ,                 funcion = ", ".join(cuerpo),             ,                 codigo.write(nombre_funcion+","+parametros+","+modulo+","+funcion+"\n"),     ,     elif nombre_archivo == 'comentarios.csv':,         ,         with open (nombre_archivo,"a") as codigo:,             ,             for elementos in Estructura_de_datos:,                 ,                 nombre_funcion = elementos[0],                 nombre_autor = elementos[1][0],                 nombre_ayuda = elementos[1][1],                 resto = elementos[1][2], ,             ,                 funcion = ", ".join(resto),             ,                 codigo.write(nombre_funcion + "," + nombre_autor + "," + nombre_ayuda + "," + funcion + "\n"),     ,     return None
armar_diccionarios,,consulta_de_funciones.py,,     diccionario_fuente_unico = {},     diccionario_comentarios = {},     with open("fuente_unico.csv", "r") as fuente_unico:,         linea = fuente_unico.readline().rstrip("\n"),         while linea != "":,             datos = linea.split(","),             if len(datos) > 1:,                 nombre_funcion = datos[0],                 parametros = datos[1],                 modulo = datos[2],                 cuerpo = [datos[3] + i for i in datos[4:]],                 diccionario_fuente_unico[nombre_funcion.rstrip(" ")] = [parametros, modulo, cuerpo],                 linea = fuente_unico.readline().rstrip("\n"), ,     with open("comentarios.csv", "r") as comentarios:,         linea_comentarios = comentarios.readline().rstrip("\n"),         while linea_comentarios:,             datos2 = linea_comentarios.split(","),             nombre_funcion = datos2[0],             autor = datos2[1],             ayuda = datos2[2],             lista_comentarios = datos2[3:],             diccionario_comentarios[nombre_funcion.rstrip(" ")] = [autor, ayuda, lista_comentarios],             linea_comentarios = comentarios.readline().rstrip("\n"),         return diccionario_fuente_unico, diccionario_comentarios
armar_csv_funciones,archivo,m_generar_archivos_csv.py,    ,     ,     nombre_archivo = "fuente_unico.csv",     datos = {},     ,     modulos = abro_ar(archivo),     ,     for modulo in modulos:,         lineas = abro_ar(modulo), ,         for linea in lineas:,                   ,             if linea.startswith('def '):,                 funcion = linea,                 index_inicial = lineas.index(funcion) + 1,                 nombre_funcion = funcion.split('def ')[1].lstrip().split('(')[0],                 parametros = funcion.split('(')[1].lstrip().split(')')[0], ,             elif linea.strip().startswith('return'):,                 linea_return = linea,                 index_final = lineas.index(linea_return) + 1,                 cuerpo = lineas[index_inicial:index_final],                 cuerpo_sin_comment = armar_csv_comentarios(cuerpo,nombre_funcion),                 datos[nombre_funcion] = [parametros,modulo,cuerpo_sin_comment], ,     funciones_alfabeto = ordenar_alfabeticamente(datos),   ,     return modulo_csv.armo_csv(funciones_alfabeto,nombre_archivo)
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,    ,     ,     comentario_triple = '\"\"\"',     nombre_archivo = 'comentarios.csv',     autor = "[Autor:",     ayuda = "[Ayuda:",     nombre_autor = "",     nombre_ayuda = "",     resto = []   ,     datos_comentarios = {}, ,     lista = lista_cuerpo    ,     resto = [j for j in lineas_comentadas if autor not in j and ayuda not in j],     cuerpo_sin_comentarios = [x for x in lista if x not in lineas_comentadas],     ,     for comentarios in lineas_comentadas:,         if autor in comentarios:,             nombre_autor = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],         elif ayuda in comentarios:,             nombre_ayuda = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],             ,             datos_comentarios[nombre_funcion] = [nombre_autor,nombre_ayuda,resto],             ,     comentarios_alfabeto = ordenar_alfabeticamente(datos_comentarios),     ,     modulo_csv.armo_csv(comentarios_alfabeto,nombre_archivo),     ,     return cuerpo_sin_comentarios
abro_ar,archivo,m_generar_archivos_csv.py,    , , ,     with open(archivo, encoding="utf8") as archivo_completo: ,        ,         return leer(archivo_completo)
solicitar_valor,mensaje, minimo, maximo,app_matematica.py,       [Ayuda: Solicitar el ingreso de un valor y devolverlo, asegurando que,         estara entre el minimo y el maximo pasado por parametro],     valor = input(mensaje),     while (not valor.isdigit()) or ((int(valor) < minimo) or (int(valor) > maximo)):,         print("Error: Valor debe estar entre", minimo, "y", maximo),         valor = input(mensaje),         ,     return int(valor)
sacar_corchetes,cadena,consulta_de_funciones.py,    if cadena.endswith(" "):,         sin_corchetes = cadena.lstrip("[").rstrip("] "),     else:,         sin_corchetes = cadena.lstrip("[").rstrip("]"),     return sin_corchetes
potencia,base, exponente,lib_matematica.py,
organizar_datos,lista,Panel_General.py,       [Ayuda: Crea el diccionario inicial y contiene los campos Nombre,        de Funcion, Cantidad de Parametros, Canitdad de Lineas,     j = 0,     primeros_3 = {"Nombre de Funcion": lista[0] + lista[2], "Cantidad de Parametros": lista[1].count('('),,                   "Cantidad de Lineas": len(lista) - 3},     return primeros_3
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,    ,     ,     return sorted(diccionario.items(), key = lambda clave: clave[0], reverse = True)
mcm,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCM (minimo comun multiplo) entre los dos numeros,         recibidos. En caso de no existir, devolverá -1.,         Para el calculo se utiliza mcm(a,b) = (a*b)/MCD(a,b)],     return (nro_1 * nro_2)//mcd(nro_1, nro_2)
mcd,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCD entre los dos numeros recibidos, utilizando el,         metodo de Euclides. En caso de no existir MCD, devolverá -1.], ,     if abs(nro_1) < abs(nro_2):,         menor = abs(nro_1),         mayor = abs(nro_2),     else:,         menor = abs(nro_2),         mayor = abs(nro_1), ,         devovler = -1,     elif menor == 0:,         devolver = mayor,         dividendo = mayor,         divisor = menor,         resto = mayor % divisor, ,         while resto != 0:,             dividendo = divisor,             divisor = resto,             resto = dividendo % divisor, ,         devolver = divisor, ,     return devolver
main,,programa_principal.py,    ,     , ,     import m_generar_archivos_csv,     txt = 'programas.txt',     m_generar_archivos_csv.armar_csv_funciones(txt),     print("llegue"),     import Informacion_por_desarrollador,     informacion,porcentaje = Informacion_por_desarrollador.capturo_datos(),     Informacion_por_desarrollador.participacion_info(informacion,porcentaje),     ,     return None
leer,archivo,m_generar_archivos_csv.py,    ,     ,     lineas = [linea.rstrip('\n') for linea in archivo],     ,     return lineas
impresiones ,contenido_a_mostrar,muestro_salida.py,    , ,     print(contenido_a_mostrar), ,     return None
generar_lista_total,dic,consulta_de_funciones.py,    lista_total = [[]],     for i in dic:,         ultima_lista = lista_total[-1],         if len(ultima_lista) < 5:,             ultima_lista.append(format(i, "<26s")),         else:,             lista_total.append([]),             ultima_lista = lista_total[-1],             ultima_lista.append(format(i, "<26s")),     if len(lista_total[-1]) < 5:,         for i in range(0, 5-len(lista_total[-1])):,             lista_total[-1].append(format(" ", "<26s")),     return lista_total
factorial,n,lib_matematica.py,       [Ayuda: Calcula el factorial de el numero recibido, que debe ser,         mayor o igual a cero], ,     resultado = 1,     for i in range(2, n+1):,         resultado = resultado * i, ,     return resultado
es_primo,valor,lib_matematica.py,       [Ayuda: Evlua si el numero recibido es primo o no, devolviendo True en,         caso de serlo, y False en caso contrario.], ,     devolver = True,     if valor <= 1:,         devolver = False,     else:,         divisor = 2,         while (((valor % divisor)!=0) and (divisor <= valor/2)):,             divisor += 1, ,         if divisor <= valor/2:,             devolver = False, ,         return devolver
contar_invocaciones,nombre_funcion, lista,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de Invoca,        ciones],     i = 0,     invocaciones_dict = {"Cantidad de Invocaciones": 0},     while i < len(lista):,         j = 4,         while j < len(lista[i]):,             if nombre_funcion in lista[i][j]:,                 invocaciones_dict["Cantidad de Invocaciones"] += 1,             j = j + 1,         i = i + 1,     return invocaciones_dict
contar_funciones,linea,contar_funciones.py,    cantidad_funciones = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": 0},     if linea.strip().startswith("if"):,         cantidad_funciones["if"] += 1,     elif linea.strip().startswith("while"):,         cantidad_funciones["while"] += 1,     elif linea.strip().startswith("for"):,         cantidad_funciones["for"] += 1,     elif linea.strip().startswith("return"):,         cantidad_funciones["returns"] += 1,     elif linea.strip().startswith("break"):,         cantidad_funciones["break"] += 1,     elif linea.strip().startswith("exit"):,         cantidad_funciones["exit"] += 1,     elif linea.strip().startswith("[Ayuda: ]"):,         cantidad_funciones["ayuda"] += 1,     return cantidad_funciones
contar_elementos_varios,lista, lista_comentarios,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de if, while,        for, returns, break, exit y ayuda,     cantidad_elementos = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": "NO"},     j = 4,     while j < len(lista):,         if lista[j].strip().startswith("if") or lista[j].strip().startswith(,             cantidad_elementos["if"] += 1,         elif lista[j].strip().startswith("while"):,             cantidad_elementos["while"] += 1,         elif lista[j].strip().startswith("for"):,             cantidad_elementos["for"] += 1,         elif lista[j].strip().startswith("return"):,             cantidad_elementos["returns"] += 1,         elif lista[j].strip().startswith("break"):,             cantidad_elementos["break"] += 1,         elif lista[j].strip().startswith("exit"):,             cantidad_elementos["exit"] += 1,         if lista_comentarios[2].strip().startswith("[Ayuda:"):,             cantidad_elementos["ayuda"] = "SI",         j = j + 1,     return cantidad_elementos
capturo_datos,,Informacion_por_desarrollador.py,    ,     (Nombres de las funciones, autor de la funcion , lineas por funcion y,     porcentaje de lineas del autor, sobre lineas totales del trabajo. ) ], ,     informacion_deseada = {},     ,     lineas_totales_por_autor = {}, ,     total_linea = 0, ,     with open("comentarios.csv","rt") as archivo_comentarios:,         ,         linea_archivos_comentarios = archivo_comentarios.readline(), ,         while linea_archivos_comentarios != "":,             ,             linea_a_lista_de_datos = linea_archivos_comentarios.split(","), ,             nombre_funcion = linea_a_lista_de_datos[0], ,             autor = linea_a_lista_de_datos[1].split(": ")[1].rstrip("]"), ,             informacion_deseada[nombre_funcion] = [autor,None], ,             linea_archivos_comentarios = archivo_comentarios.readline(), ,     with open ("fuente_unico.csv","rt") as archivo_fuente_unico:, ,         linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,         while linea_archivos_fuente_unico != "":, ,             linea_a_lista_de_datos = linea_archivos_fuente_unico.split(","),             ,             contador_lineas = 0, ,             funcion_actual = linea_a_lista_de_datos[0],             ,             total_linea += len(linea_a_lista_de_datos[3:]),             ,             contador_lineas = len(linea_a_lista_de_datos[3:]),             ,             for clave in informacion_deseada.keys():,                 ,                 if clave == funcion_actual:,                     informacion_deseada[clave][1] = contador_lineas,                     ,                     if informacion_deseada[clave][0] in lineas_totales_por_autor.keys():,                         lineas_totales_por_autor[informacion_deseada[clave][0]]+=contador_lineas,                     ,                     else:,                         lineas_totales_por_autor[informacion_deseada[clave][0]]=contador_lineas, ,             linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,     porcentajes ={}, ,     for clave in lineas_totales_por_autor.keys():,     ,         porcentajes[clave]=int((lineas_totales_por_autor[clave]/total_linea)*100), ,     ,     datos_finales = sorted(informacion_deseada.items(), key = lambda autor: autor[1][0]),     ,     return datos_finales,porcentajes
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,    ,         [Ayuda: Aquí se multiplica un espacio por un numero x,         El 8 es cantidad de caracateres que tiene una tabulacion,,         len(nom_fun) es la cantida de caracteres que tiene el nom_fun.,         Despues quiero que partir del carater 32 obtener la cant.lineas.,         Esta cuanta me asegura que el valor lineas_f este uno debajo del otro,,         multiplicando un str espacio la cantidad de veces nesesaria para cada caso. ],   ,     if 8 + len(nombre_funcion)<33:,         espacios = -1 * (8 + len(nombre_funcion) - 33),     else:,         espacios = 2, ,     return espacios  
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,    ,     ,     if nombre_archivo == 'fuente_unico.csv':,     ,         with open (nombre_archivo,"a") as codigo:,             ,             for clave in Estructura_de_datos:,                 ,                 nombre_funcion = clave[0],                 parametros = clave[1][0],                 modulo = clave[1][1],                 cuerpo = clave[1][2],                 ,                 funcion = "\n".join(cuerpo),             ,                 funcion = ", ".join(cuerpo),             ,                 codigo.write(nombre_funcion+","+parametros+","+modulo+","+funcion+"\n"),     ,     elif nombre_archivo == 'comentarios.csv':,         ,         with open (nombre_archivo,"a") as codigo:,             ,             for elementos in Estructura_de_datos:,                 ,                 nombre_funcion = elementos[0],                 nombre_autor = elementos[1][0],                 nombre_ayuda = elementos[1][1],                 resto = elementos[1][2], ,             ,                 funcion = ", ".join(resto),             ,                 codigo.write(nombre_funcion + "," + nombre_autor + "," + nombre_ayuda + "," + funcion + "\n"),     ,     return None
armar_diccionarios,,consulta_de_funciones.py,,     diccionario_fuente_unico = {},     diccionario_comentarios = {},     with open("fuente_unico.csv", "r") as fuente_unico:,         linea = fuente_unico.readline().rstrip("\n"),         while linea != "":,             datos = linea.split(","),             if len(datos) > 1:,                 nombre_funcion = datos[0],                 parametros = datos[1],                 modulo = datos[2],                 cuerpo = [datos[3] + i for i in datos[4:]],                 diccionario_fuente_unico[nombre_funcion.rstrip(" ")] = [parametros, modulo, cuerpo],                 linea = fuente_unico.readline().rstrip("\n"), ,     with open("comentarios.csv", "r") as comentarios:,         linea_comentarios = comentarios.readline().rstrip("\n"),         while linea_comentarios:,             datos2 = linea_comentarios.split(","),             nombre_funcion = datos2[0],             autor = datos2[1],             ayuda = datos2[2],             lista_comentarios = datos2[3:],             diccionario_comentarios[nombre_funcion.rstrip(" ")] = [autor, ayuda, lista_comentarios],             linea_comentarios = comentarios.readline().rstrip("\n"),         return diccionario_fuente_unico, diccionario_comentarios
armar_csv_funciones,archivo,m_generar_archivos_csv.py,    ,     ,     nombre_archivo = "fuente_unico.csv",     datos = {},     ,     modulos = abro_ar(archivo),     ,     for modulo in modulos:,         lineas = abro_ar(modulo), ,         for linea in lineas:,                   ,             if linea.startswith('def '):,                 funcion = linea,                 index_inicial = lineas.index(funcion) + 1,                 nombre_funcion = funcion.split('def ')[1].lstrip().split('(')[0],                 parametros = funcion.split('(')[1].lstrip().split(')')[0], ,             elif linea.strip().startswith('return'):,                 linea_return = linea,                 index_final = lineas.index(linea_return) + 1,                 cuerpo = lineas[index_inicial:index_final],                 cuerpo_sin_comment = armar_csv_comentarios(cuerpo,nombre_funcion),                 datos[nombre_funcion] = [parametros,modulo,cuerpo_sin_comment], ,     funciones_alfabeto = ordenar_alfabeticamente(datos),   ,     return modulo_csv.armo_csv(funciones_alfabeto,nombre_archivo)
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,    ,     ,     comentario_triple = '\"\"\"',     nombre_archivo = 'comentarios.csv',     autor = "[Autor:",     ayuda = "[Ayuda:",     nombre_autor = "",     nombre_ayuda = "",     resto = []   ,     datos_comentarios = {}, ,     lista = lista_cuerpo    ,     resto = [j for j in lineas_comentadas if autor not in j and ayuda not in j],     cuerpo_sin_comentarios = [x for x in lista if x not in lineas_comentadas],     ,     for comentarios in lineas_comentadas:,         if autor in comentarios:,             nombre_autor = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],         elif ayuda in comentarios:,             nombre_ayuda = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],             ,             datos_comentarios[nombre_funcion] = [nombre_autor,nombre_ayuda,resto],             ,     comentarios_alfabeto = ordenar_alfabeticamente(datos_comentarios),     ,     modulo_csv.armo_csv(comentarios_alfabeto,nombre_archivo),     ,     return cuerpo_sin_comentarios
abro_ar,archivo,m_generar_archivos_csv.py,    , , ,     with open(archivo, encoding="utf8") as archivo_completo: ,        ,         return leer(archivo_completo)
solicitar_valor,mensaje, minimo, maximo,app_matematica.py,       [Ayuda: Solicitar el ingreso de un valor y devolverlo, asegurando que,         estara entre el minimo y el maximo pasado por parametro],     valor = input(mensaje),     while (not valor.isdigit()) or ((int(valor) < minimo) or (int(valor) > maximo)):,         print("Error: Valor debe estar entre", minimo, "y", maximo),         valor = input(mensaje),         ,     return int(valor)
sacar_corchetes,cadena,consulta_de_funciones.py,    if cadena.endswith(" "):,         sin_corchetes = cadena.lstrip("[").rstrip("] "),     else:,         sin_corchetes = cadena.lstrip("[").rstrip("]"),     return sin_corchetes
potencia,base, exponente,lib_matematica.py,
organizar_datos,lista,Panel_General.py,       [Ayuda: Crea el diccionario inicial y contiene los campos Nombre,        de Funcion, Cantidad de Parametros, Canitdad de Lineas,     j = 0,     primeros_3 = {"Nombre de Funcion": lista[0] + lista[2], "Cantidad de Parametros": lista[1].count('('),,                   "Cantidad de Lineas": len(lista) - 3},     return primeros_3
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,    ,     ,     return sorted(diccionario.items(), key = lambda clave: clave[0], reverse = True)
mcm,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCM (minimo comun multiplo) entre los dos numeros,         recibidos. En caso de no existir, devolverá -1.,         Para el calculo se utiliza mcm(a,b) = (a*b)/MCD(a,b)],     return (nro_1 * nro_2)//mcd(nro_1, nro_2)
mcd,nro_1, nro_2,lib_matematica.py,       [Ayuda: Calcula el MCD entre los dos numeros recibidos, utilizando el,         metodo de Euclides. En caso de no existir MCD, devolverá -1.], ,     if abs(nro_1) < abs(nro_2):,         menor = abs(nro_1),         mayor = abs(nro_2),     else:,         menor = abs(nro_2),         mayor = abs(nro_1), ,         devovler = -1,     elif menor == 0:,         devolver = mayor,         dividendo = mayor,         divisor = menor,         resto = mayor % divisor, ,         while resto != 0:,             dividendo = divisor,             divisor = resto,             resto = dividendo % divisor, ,         devolver = divisor, ,     return devolver
main,,programa_principal.py,    ,     , ,     import m_generar_archivos_csv,     txt = 'programas.txt',     m_generar_archivos_csv.armar_csv_funciones(txt),     print("llegue"),     import Informacion_por_desarrollador,     informacion,porcentaje = Informacion_por_desarrollador.capturo_datos(),     Informacion_por_desarrollador.participacion_info(informacion,porcentaje),     ,     return None
leer,archivo,m_generar_archivos_csv.py,    ,     ,     lineas = [linea.rstrip('\n') for linea in archivo],     ,     return lineas
impresiones ,contenido_a_mostrar,muestro_salida.py,    , ,     print(contenido_a_mostrar), ,     return None
generar_lista_total,dic,consulta_de_funciones.py,    lista_total = [[]],     for i in dic:,         ultima_lista = lista_total[-1],         if len(ultima_lista) < 5:,             ultima_lista.append(format(i, "<26s")),         else:,             lista_total.append([]),             ultima_lista = lista_total[-1],             ultima_lista.append(format(i, "<26s")),     if len(lista_total[-1]) < 5:,         for i in range(0, 5-len(lista_total[-1])):,             lista_total[-1].append(format(" ", "<26s")),     return lista_total
factorial,n,lib_matematica.py,       [Ayuda: Calcula el factorial de el numero recibido, que debe ser,         mayor o igual a cero], ,     resultado = 1,     for i in range(2, n+1):,         resultado = resultado * i, ,     return resultado
es_primo,valor,lib_matematica.py,       [Ayuda: Evlua si el numero recibido es primo o no, devolviendo True en,         caso de serlo, y False en caso contrario.], ,     devolver = True,     if valor <= 1:,         devolver = False,     else:,         divisor = 2,         while (((valor % divisor)!=0) and (divisor <= valor/2)):,             divisor += 1, ,         if divisor <= valor/2:,             devolver = False, ,         return devolver
contar_invocaciones,nombre_funcion, lista,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de Invoca,        ciones],     i = 0,     invocaciones_dict = {"Cantidad de Invocaciones": 0},     while i < len(lista):,         j = 4,         while j < len(lista[i]):,             if nombre_funcion in lista[i][j]:,                 invocaciones_dict["Cantidad de Invocaciones"] += 1,             j = j + 1,         i = i + 1,     return invocaciones_dict
contar_funciones,linea,contar_funciones.py,    cantidad_funciones = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": 0},     if linea.strip().startswith("if"):,         cantidad_funciones["if"] += 1,     elif linea.strip().startswith("while"):,         cantidad_funciones["while"] += 1,     elif linea.strip().startswith("for"):,         cantidad_funciones["for"] += 1,     elif linea.strip().startswith("return"):,         cantidad_funciones["returns"] += 1,     elif linea.strip().startswith("break"):,         cantidad_funciones["break"] += 1,     elif linea.strip().startswith("exit"):,         cantidad_funciones["exit"] += 1,     elif linea.strip().startswith("[Ayuda: ]"):,         cantidad_funciones["ayuda"] += 1,     return cantidad_funciones
contar_elementos_varios,lista, lista_comentarios,Panel_General.py,       [Ayuda: Crea otro diccionario que contiene la cantidad de if, while,        for, returns, break, exit y ayuda,     cantidad_elementos = {"if": 0, "while": 0, "for": 0, "returns": 0, "break": 0, "exit": 0, "ayuda": "NO"},     j = 4,     while j < len(lista):,         if lista[j].strip().startswith("if") or lista[j].strip().startswith(,             cantidad_elementos["if"] += 1,         elif lista[j].strip().startswith("while"):,             cantidad_elementos["while"] += 1,         elif lista[j].strip().startswith("for"):,             cantidad_elementos["for"] += 1,         elif lista[j].strip().startswith("return"):,             cantidad_elementos["returns"] += 1,         elif lista[j].strip().startswith("break"):,             cantidad_elementos["break"] += 1,         elif lista[j].strip().startswith("exit"):,             cantidad_elementos["exit"] += 1,         if lista_comentarios[2].strip().startswith("[Ayuda:"):,             cantidad_elementos["ayuda"] = "SI",         j = j + 1,     return cantidad_elementos
capturo_datos,,Informacion_por_desarrollador.py,    ,     (Nombres de las funciones, autor de la funcion , lineas por funcion y,     porcentaje de lineas del autor, sobre lineas totales del trabajo. ) ], ,     informacion_deseada = {},     ,     lineas_totales_por_autor = {}, ,     total_linea = 0, ,     with open("comentarios.csv","rt") as archivo_comentarios:,         ,         linea_archivos_comentarios = archivo_comentarios.readline(), ,         while linea_archivos_comentarios != "":,             ,             linea_a_lista_de_datos = linea_archivos_comentarios.split(","), ,             nombre_funcion = linea_a_lista_de_datos[0], ,             autor = linea_a_lista_de_datos[1].split(": ")[1].rstrip("]"), ,             informacion_deseada[nombre_funcion] = [autor,None], ,             linea_archivos_comentarios = archivo_comentarios.readline(), ,     with open ("fuente_unico.csv","rt") as archivo_fuente_unico:, ,         linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,         while linea_archivos_fuente_unico != "":, ,             linea_a_lista_de_datos = linea_archivos_fuente_unico.split(","),             ,             contador_lineas = 0, ,             funcion_actual = linea_a_lista_de_datos[0],             ,             total_linea += len(linea_a_lista_de_datos[3:]),             ,             contador_lineas = len(linea_a_lista_de_datos[3:]),             ,             for clave in informacion_deseada.keys():,                 ,                 if clave == funcion_actual:,                     informacion_deseada[clave][1] = contador_lineas,                     ,                     if informacion_deseada[clave][0] in lineas_totales_por_autor.keys():,                         lineas_totales_por_autor[informacion_deseada[clave][0]]+=contador_lineas,                     ,                     else:,                         lineas_totales_por_autor[informacion_deseada[clave][0]]=contador_lineas, ,             linea_archivos_fuente_unico = archivo_fuente_unico.readline(), ,     porcentajes ={}, ,     for clave in lineas_totales_por_autor.keys():,     ,         porcentajes[clave]=int((lineas_totales_por_autor[clave]/total_linea)*100), ,     ,     datos_finales = sorted(informacion_deseada.items(), key = lambda autor: autor[1][0]),     ,     return datos_finales,porcentajes
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,    ,         [Ayuda: Aquí se multiplica un espacio por un numero x,         El 8 es cantidad de caracateres que tiene una tabulacion,,         len(nom_fun) es la cantida de caracteres que tiene el nom_fun.,         Despues quiero que partir del carater 32 obtener la cant.lineas.,         Esta cuanta me asegura que el valor lineas_f este uno debajo del otro,,         multiplicando un str espacio la cantidad de veces nesesaria para cada caso. ],   ,     if 8 + len(nombre_funcion)<33:,         espacios = -1 * (8 + len(nombre_funcion) - 33),     else:,         espacios = 2, ,     return espacios  
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,    ,     ,     if nombre_archivo == 'fuente_unico.csv':,     ,         with open (nombre_archivo,"a") as codigo:,             ,             for clave in Estructura_de_datos:,                 ,                 nombre_funcion = clave[0],                 parametros = clave[1][0],                 modulo = clave[1][1],                 cuerpo = clave[1][2],                 ,                 funcion = "\n".join(cuerpo),             ,                 funcion = ", ".join(cuerpo),             ,                 codigo.write(nombre_funcion+","+parametros+","+modulo+","+funcion+"\n"),     ,     elif nombre_archivo == 'comentarios.csv':,         ,         with open (nombre_archivo,"a") as codigo:,             ,             for elementos in Estructura_de_datos:,                 ,                 nombre_funcion = elementos[0],                 nombre_autor = elementos[1][0],                 nombre_ayuda = elementos[1][1],                 resto = elementos[1][2], ,             ,                 funcion = ", ".join(resto),             ,                 codigo.write(nombre_funcion + "," + nombre_autor + "," + nombre_ayuda + "," + funcion + "\n"),     ,     return None
armar_diccionarios,,consulta_de_funciones.py,,     diccionario_fuente_unico = {},     diccionario_comentarios = {},     with open("fuente_unico.csv", "r") as fuente_unico:,         linea = fuente_unico.readline().rstrip("\n"),         while linea != "":,             datos = linea.split(","),             if len(datos) > 1:,                 nombre_funcion = datos[0],                 parametros = datos[1],                 modulo = datos[2],                 cuerpo = [datos[3] + i for i in datos[4:]],                 diccionario_fuente_unico[nombre_funcion.rstrip(" ")] = [parametros, modulo, cuerpo],                 linea = fuente_unico.readline().rstrip("\n"), ,     with open("comentarios.csv", "r") as comentarios:,         linea_comentarios = comentarios.readline().rstrip("\n"),         while linea_comentarios:,             datos2 = linea_comentarios.split(","),             nombre_funcion = datos2[0],             autor = datos2[1],             ayuda = datos2[2],             lista_comentarios = datos2[3:],             diccionario_comentarios[nombre_funcion.rstrip(" ")] = [autor, ayuda, lista_comentarios],             linea_comentarios = comentarios.readline().rstrip("\n"),         return diccionario_fuente_unico, diccionario_comentarios
armar_csv_funciones,archivo,m_generar_archivos_csv.py,    ,     ,     nombre_archivo = "fuente_unico.csv",     datos = {},     ,     modulos = abro_ar(archivo),     ,     for modulo in modulos:,         lineas = abro_ar(modulo), ,         for linea in lineas:,                   ,             if linea.startswith('def '):,                 funcion = linea,                 index_inicial = lineas.index(funcion) + 1,                 nombre_funcion = funcion.split('def ')[1].lstrip().split('(')[0],                 parametros = funcion.split('(')[1].lstrip().split(')')[0], ,             elif linea.strip().startswith('return'):,                 linea_return = linea,                 index_final = lineas.index(linea_return) + 1,                 cuerpo = lineas[index_inicial:index_final],                 cuerpo_sin_comment = armar_csv_comentarios(cuerpo,nombre_funcion),                 datos[nombre_funcion] = [parametros,modulo,cuerpo_sin_comment], ,     funciones_alfabeto = ordenar_alfabeticamente(datos),   ,     return modulo_csv.armo_csv(funciones_alfabeto,nombre_archivo)
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,    ,     ,     comentario_triple = '\"\"\"',     nombre_archivo = 'comentarios.csv',     autor = "[Autor:",     ayuda = "[Ayuda:",     nombre_autor = "",     nombre_ayuda = "",     resto = []   ,     datos_comentarios = {}, ,     lista = lista_cuerpo    ,     resto = [j for j in lineas_comentadas if autor not in j and ayuda not in j],     cuerpo_sin_comentarios = [x for x in lista if x not in lineas_comentadas],     ,     for comentarios in lineas_comentadas:,         if autor in comentarios:,             nombre_autor = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],         elif ayuda in comentarios:,             nombre_ayuda = comentarios.split(comentario_triple)[1].lstrip().split(comentario_triple)[0],             ,             datos_comentarios[nombre_funcion] = [nombre_autor,nombre_ayuda,resto],             ,     comentarios_alfabeto = ordenar_alfabeticamente(datos_comentarios),     ,     modulo_csv.armo_csv(comentarios_alfabeto,nombre_archivo),     ,     return cuerpo_sin_comentarios
abro_ar,archivo,m_generar_archivos_csv.py,    , , ,     with open(archivo, encoding="utf8") as archivo_completo: ,        ,         return leer(archivo_completo)
abro_ar,archivo,m_generar_archivos_csv.py,
archivo_participacion_txt ,agrego,Informacion_por_desarrollador.py,
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,
armar_csv_funciones,archivo,m_generar_archivos_csv.py,
armar_diccionarios,,consulta_de_funciones.py,
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,
capturo_datos,,Informacion_por_desarrollador.py,
consultar_funciones,diccionario_fuente, diccionario_comentarios,consulta_de_funciones.py,
contar_elementos_varios,lista, lista_comentarios,Panel_General.py,
contar_funciones,linea,contar_funciones.py,
contar_invocaciones,nombre_funcion, lista,Panel_General.py,
es_primo,valor,lib_matematica.py,
factorial,n,lib_matematica.py,
generar_lista_total,dic,consulta_de_funciones.py,
generar_txt,dict_fuente, dict_comentarios, txt,consulta_de_funciones.py,
impresiones ,contenido_a_mostrar,muestro_salida.py,
imprimir_funciones,listas,consulta_de_funciones.py,
leer,archivo,m_generar_archivos_csv.py,
main,,programa_principal.py,
mcd,nro_1, nro_2,lib_matematica.py,
mcm,nro_1, nro_2,lib_matematica.py,
menu_MCD,,app_matematica.py,
menu_MCM,,app_matematica.py,
menu_elegir,,app_matematica.py,
menu_factorial,,app_matematica.py,
menu_opciones,,app_matematica.py,
menu_potencia,,app_matematica.py,
menu_primo,,app_matematica.py,
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,
organizar_datos,lista,Panel_General.py,
panel_principal,,Panel_General.py,
participacion_info ,informacion,informacion2,Informacion_por_desarrollador.py,
potencia,base, exponente,lib_matematica.py,
sacar_corchetes,cadena,consulta_de_funciones.py,
solicitar_valor,mensaje, minimo, maximo,app_matematica.py,
abro_ar,archivo,m_generar_archivos_csv.py,
archivo_participacion_txt ,agrego,Informacion_por_desarrollador.py,
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,
armar_csv_funciones,archivo,m_generar_archivos_csv.py,
armar_diccionarios,,consulta_de_funciones.py,
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,
capturo_datos,,Informacion_por_desarrollador.py,
consultar_funciones,diccionario_fuente, diccionario_comentarios,consulta_de_funciones.py,
contar_elementos_varios,lista, lista_comentarios,Panel_General.py,
contar_funciones,linea,contar_funciones.py,
contar_invocaciones,nombre_funcion, lista,Panel_General.py,
es_primo,valor,lib_matematica.py,
factorial,n,lib_matematica.py,
generar_lista_total,dic,consulta_de_funciones.py,
generar_txt,dict_fuente, dict_comentarios, txt,consulta_de_funciones.py,
impresiones ,contenido_a_mostrar,muestro_salida.py,
imprimir_funciones,listas,consulta_de_funciones.py,
leer,archivo,m_generar_archivos_csv.py,
main,,programa_principal.py,
mcd,nro_1, nro_2,lib_matematica.py,
mcm,nro_1, nro_2,lib_matematica.py,
menu_MCD,,app_matematica.py,
menu_MCM,,app_matematica.py,
menu_elegir,,app_matematica.py,
menu_factorial,,app_matematica.py,
menu_opciones,,app_matematica.py,
menu_potencia,,app_matematica.py,
menu_primo,,app_matematica.py,
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,
organizar_datos,lista,Panel_General.py,
panel_principal,,Panel_General.py,
participacion_info ,informacion,informacion2,Informacion_por_desarrollador.py,
potencia,base, exponente,lib_matematica.py,
sacar_corchetes,cadena,consulta_de_funciones.py,
solicitar_valor,mensaje, minimo, maximo,app_matematica.py,
abro_ar,archivo,m_generar_archivos_csv.py,
archivo_participacion_txt ,agrego,Informacion_por_desarrollador.py,
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,
armar_csv_funciones,archivo,m_generar_archivos_csv.py,
armar_diccionarios,,consulta_de_funciones.py,
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,
capturo_datos,,Informacion_por_desarrollador.py,
consultar_funciones,diccionario_fuente, diccionario_comentarios,consulta_de_funciones.py,
contar_elementos_varios,lista, lista_comentarios,Panel_General.py,
contar_funciones,linea,contar_funciones.py,
contar_invocaciones,nombre_funcion, lista,Panel_General.py,
es_primo,valor,lib_matematica.py,
factorial,n,lib_matematica.py,
generar_lista_total,dic,consulta_de_funciones.py,
generar_txt,dict_fuente, dict_comentarios, txt,consulta_de_funciones.py,
impresiones ,contenido_a_mostrar,muestro_salida.py,
imprimir_funciones,listas,consulta_de_funciones.py,
leer,archivo,m_generar_archivos_csv.py,
main,,programa_principal.py,
mcd,nro_1, nro_2,lib_matematica.py,
mcm,nro_1, nro_2,lib_matematica.py,
menu_MCD,,app_matematica.py,
menu_MCM,,app_matematica.py,
menu_elegir,,app_matematica.py,
menu_factorial,,app_matematica.py,
menu_opciones,,app_matematica.py,
menu_potencia,,app_matematica.py,
menu_primo,,app_matematica.py,
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,
organizar_datos,lista,Panel_General.py,
panel_principal,,Panel_General.py,
participacion_info ,informacion,informacion2,Informacion_por_desarrollador.py,
potencia,base, exponente,lib_matematica.py,
sacar_corchetes,cadena,consulta_de_funciones.py,
solicitar_valor,mensaje, minimo, maximo,app_matematica.py,
abro_ar,archivo,m_generar_archivos_csv.py,
archivo_participacion_txt ,agrego,Informacion_por_desarrollador.py,
armar_csv_comentarios,lista_cuerpo,nombre_funcion,m_generar_archivos_csv.py,
armar_csv_funciones,archivo,m_generar_archivos_csv.py,
armar_diccionarios,,consulta_de_funciones.py,
armo_csv,Estructura_de_datos,nombre_archivo,modulo_csv.py,
cantidad_de_espacios,nombre_funcion,Informacion_por_desarrollador.py,
capturo_datos,,Informacion_por_desarrollador.py,
consultar_funciones,diccionario_fuente, diccionario_comentarios,consulta_de_funciones.py,
contar_elementos_varios,lista, lista_comentarios,Panel_General.py,
contar_funciones,linea,contar_funciones.py,
contar_invocaciones,nombre_funcion, lista,Panel_General.py,
es_primo,valor,lib_matematica.py,
factorial,n,lib_matematica.py,
generar_lista_total,dic,consulta_de_funciones.py,
generar_txt,dict_fuente, dict_comentarios, txt,consulta_de_funciones.py,
impresiones ,contenido_a_mostrar,muestro_salida.py,
imprimir_funciones,listas,consulta_de_funciones.py,
leer,archivo,m_generar_archivos_csv.py,
main,,programa_principal.py,
mcd,nro_1, nro_2,lib_matematica.py,
mcm,nro_1, nro_2,lib_matematica.py,
menu_MCD,,app_matematica.py,
menu_MCM,,app_matematica.py,
menu_elegir,,app_matematica.py,
menu_factorial,,app_matematica.py,
menu_opciones,,app_matematica.py,
menu_potencia,,app_matematica.py,
menu_primo,,app_matematica.py,
ordenar_alfabeticamente,diccionario,m_generar_archivos_csv.py,
organizar_datos,lista,Panel_General.py,
panel_principal,,Panel_General.py,
participacion_info ,informacion,informacion2,Informacion_por_desarrollador.py,
potencia,base, exponente,lib_matematica.py,
sacar_corchetes,cadena,consulta_de_funciones.py,
solicitar_valor,mensaje, minimo, maximo,app_matematica.py,
main,,programa_principal.py,
main,,programa_principal.py,
main,,programa_principal.py,
main,,programa_principal.py,
